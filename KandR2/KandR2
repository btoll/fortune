The model of input and output supported by the standard library is very simple.  Text input or output, regardless of where it originates or where it goes to, is dealt with as streams of characters.  A text stream is a sequence of characters divided into lines; each line consists of zero or more characters followed by a newline character.  It is the responsibility of the library to make each input or output stream conform to this model; the C programmer using the library need not worry about how lines are represented outside of the program.
        -- K & R, 2nd, Edition, ch 1, p 15
%
The body of this for loop is empty, because all of the work is done in the test and increment parts.  But the grammatical rules of C require that a for statement have a body.  The isolated semicolon, called a `null statement`, is there to satisfy that requirement.  We put it on a separate line to make it visible.
		-- K & R, 2nd Edition, ch 1, p 19
%
A character written between single quotes represents an integer value equal to the numerical value of the character in the machine's character set.  This is called a `character constant`, although it is just another way to write a small integer.
		-- K & R, 2nd Edition, ch 1, p 19
%
By definition, chars are just small integers, so char variables and constants are identical to ints in arithmetic expressions.
        -- K & R, 2nd Edition, ch 1, p 23
%
We will generally use `parameter` for a variable named in the parenthesized list in a function definition, and `argument` for the value used in a call of the function.  The terms `formal argument` and `actual argument` are sometimes used for the same distinction.
		-- K & R, 2nd Edition, ch 1, p 25
%
[P]rograms should return status to their environment.
		-- K & R, 2nd Edition, ch 1, p 26
%
Well-chosen names are good documentation.
		-- K & R, 2nd Edition, ch 1, p 26
%
In C, all function arguments are passed "by value."  This means that the called function is given the values of its arguments in temporary variables rather than the originals...[T]he called function cannot directly alter a variable in the calling function; it can only alter its private, temporary copy.
		-- K & R, 2nd Edition, ch 1, p 27
%
When the name of an array is used as an argument, the value passed to the function is the location or address of the beginning of the array -- there is no copying of array elements.  By subscripting this value, the function can access and alter any element of the array.
		-- K & R, 2nd Edition, ch 1, p 28
%
The purpose of supplying the size of an array in a declaration is to set aside storage.
		-- K & R, 2nd Edition, ch 1, p 30
%
Each local variable in a function comes into existence only when the function is called, and disappears when the function is exited.  This is why such variables are known as `automatic` variables, following terminology in other languages.  We will use the term automatic henceforth to refer to these local variables.
		-- K & R, 2nd Edition, ch 1, p 31
%
[C]ommon practice is to place definitions of all external variables at the beginning of the source file, and then omit all `extern` declarations.
		-- K & R, 2nd Edition, ch 1, p 33
%
If the program is in several source files, and a variable is defined in `file1` and used in `file2` and `file3`, then `extern` declarations are needed in `file2` and `fil` to connect the occurrences of the variable.  The usual practice is to collect `extern` declarations of variables and functions is a separate file, historically called a `header`, that is included by `#include` at the beginning of each source file.  The suffix `.h` is conventional for header names.
		-- K & R, 2nd Edition, ch 1, p 33
%
Relying too heavily on external variables is fraught with peril since it leads to programs whose data connections are not at all obvious -- variables can be changed in unexpected and even inadvertent ways, and the program is hard to modify.
		-- K & R, 2nd Edition, ch 1, p 34
%
The type of an object determines the set of values it can have and what operations can be performed on it.
		-- K & R, 2nd Edition, ch 2, p 35
%
Names are made up of letters and digits; the first character must be a letter...[d]on't begin variables names with underscore, however, since library routines often use such names...[t]raditional C practice is to use lower case for variable names, and all upper case for symbolic constants.
		-- K & R, 2nd Edition, ch 2, p 35
%
At least the first 31 characters of an internal name are significant.  For function names and external variables, the number may be less than 31, because external names may be used by assemblers and loaders over which the language has no control.  For external names, the standard guarantees uniqueness only for 6 characters and a single case.
		-- K & R, 2nd Edition, ch 2, p 35
%
There are only a few basic data types in C:

	char	a single byte, capable of holding one character
		in the local character set.
	int	an integer, typically reflecting the natural size
		of integers on the host machine.
	float	single-precision floating point.
	double	double-precision floating point.

In addition, there are a number of qualifiers that can be applied to these basic types.  `short` and `long` apply to integers:

	short int sh;
	long int counter;

The word `int` can be omitted in such declarations, and typically is.
	-- K & R, 2nd Edition, ch 2, p 36
%
Each compiler is free to choose appropriate sizes [of integers] for its own hardware, subject only to the restriction that `short`s and `int`s are at least 16 bits, `long`s are at least 32 bits, and `short` is no longer than `int`, which is no longer than `long`.
		-- K & R, 2nd Edition, ch 2, p 35
%
The qualifer `signed` or `unsigned` may be applied to `char` or any integer.  `unsigned` numbers are always positive or zero, and obey the laws of arithmetic modulo 2^n, where `n` is the number of bits in the type.  So, for instance, if `chars` are 8 bits, `unsigned char` variables have values between 0 and 255, while `signed chars` have values between -128 and 127 (int a two's-complement machine).  Whether plain `chars` are signed or unsigned is machine-dependent, but printable characters are always positive.
		-- K & R, 2nd Edition, ch 2, p 36
%
An integer constant like 1234 is an `int`.  A long constant is written with a terminal `l` (ell) or `L`, as in 123456789L; an integer too big to fit into an `int` will also be taken as a `long`.  Unsigned constants are written with a terminal `u` or `U`, and the suffix `ul` or `UL` indicates `signed long`.
		-- K & R, 2nd Edition, ch 2, p 37
%
Floating-point constants contain a decimal point (123.4) or an exponent (1e-2) or both; their type is `double`, unless suffixed.  The suffixes `f` or `F` indicate a `float` constant; `l` or `L` indicate a `long double`.
		-- K & R, 2nd Edition, ch2, p 37
%
The value of an integer can be specified in octal or hexadecimal instead of decimal.  A leading zero (0) on an integer constant means octal; a leading 0x or 0X means hexadecimal...Octal and hexadecimal constants may also be followed by `L` to make them `long` and `U` to make them unsigned (ed. note - i.e., 0XFUL).
		-- K & R, 2nd Edition, ch 2, p 37
%
A character constant is an integer, written as one character within single quotes, such as 'x'.  The value of a character constant is the numeric value of the character in the machine's character set.  For example, in the ASCII character set the character constant '0' has the value 48, which is unrelated to the numeric value 0.
		-- K & R, 2nd Edition, ch 2, p 37
%
Certain characters can be represented in character and string constants by escape sequences like \n (newline); these sequences look like two characters, but represent only one.  In addition, an arbitrary byte-sized bit pattern can be specified by

	'\ooo'

where `ooo` is one to three octal digits (0...7) or by

	'\xhh'

where `hh` is one or more hexadecimal digits (0...9, a...f, A...F).  So we might write

	#define VTAB '\013'	/* ASCII vertical tab */
	#define BELL '\007'	/* ASCII bell character */

or, in hexadecimal,

	#define VTAB '\xb'	/* ASCII vertical tab */
	#define BELL '\x7'	/* ASCII bell character */
		-- K & R, 2nd Edition, ch 2, p 37-38
%
The character constant '\0' represents the character with value zero, the null character.  '\0' is often written instead of 0 to emphasize the character nature of some expressio but the numeric value is just 0.
		-- K & R, 2nd Editionk, ch 2, p 38
%
String constants can be concatenated at compile time:

	"hello," " world"

is equivalent to

	"hello, world"

This is useful for splitting long strings across several source lines.
		-- K & R, 2nd Edition, ch 2, p 38
%
Technically, a string constant is an array of characters.  The internal representation of a string has a null character '\0' at the end, so the physical storage required is one more than the number of characters written between the quotes.  This representation means that there is no limit to how long a string can be[.]
		-- K & R, 2nd Edition, ch 2, p 38
%
There is one other kind of constant, the enumeration constant.  An enumeration is a list of constant integer values, as in

	enum boolean { NO, YES };

The first name in an `enum` has value 0, the next 1, and so on, unless explicit values are specified.  If not all values are specified, unspecified values continue the progression from the last specified value...Names in different enumerations must be distinct.  Values need not be distinct in the same enumeration.
		-- K & R, 2nd Edition, ch 2, p 39
%
Enumerations provide a convenient way to associate constant values with names, an alternative to `#define` with the advantage that the values can be generated for you.  Although variables of `enum` types may be declared, compilers need not check that what you store in such a variable is a valid value for the enumeration.  Nevertheless, enumeration variables offer the chance of checking and so are often better then `#define`s.  In addition, a debugger may be able to print values of enumeration variables in their symbolic form.
		-- K & R, 2nd Edition, ch 2, p 39
%
External and static variables are initialized to zero by default.  Automatic variables for which there is no explicit initializer have undefined (i.e., garbage) values.
		-- K & R, 2nd Edition, ch 2, p 40
%
The qualifier `const` can be applied to the declaration of any variable to specify that its value will not be changed.  For an array, the `const` qualifier says that the elements will not be altered...The `const` declaration can also be used with array arguments, to indicate that the function does not change the array:

    int strlen(const char[]);
		-- K & R, 2nd Edition, ch 2, p 40
%
The binary + and - operators have the same precedence, which is lower than the precedence of *, /, and %, which is in turn lower than unary + and -.  Arithmetic operators associate left to right.
		-- K & R, 2nd Edition, ch 2, p 41
%
The relational operators are

	>	>=	<	<=

They all have the same precedence.  Just below them in precedence are the equality operators:

	==	!=

Relational operators have lower precedence than arithmetic operators, so an expression like `i < lim-1` is taken as `i < (lim-1)`, as would be expected.
		-- K & R, 2nd Edition, ch 2, p 41
%
The precedence of && is higher than ||, and both are lower than relational and equality operators, so expressions like

	i<lim-1 && (c = getchar()) != '\n' && c != EOF

need no extra parentheses.
		-- K & R, 2nd Edition, ch 2, p 42
%
By definition, the numeric value of a relational or logical expression is 1 if the relation is true, and 0 if the relation is false.
		-- K & R, 2nd Edition, ch 2, p 42
%
The unary negation operator ! converts a non-zero operand into 0, and a zero operand into a 1.
		-- K & R, 2nd Edition, ch 2, p 42
%
When an operator has operands of different types, they are converted to a common type according to a small number of rules.  In general, the only automatic conversions are those that convert a "narrower" operand into a "wider" one without losing information, such as converting an interger to a floating point in an expression like `f + i`.  Expressions that don't make sense, like using a `float` as a subscript, are disallowed.  Expressions that might lose information, like assigning a longer integer type to a shorter, or a floating-point type to an integer, may draw a warning, but they are not illegal.
		-- K & R, 2nd Edition, ch 2, p 42
%
There is one subtle point about the conversion of characters to integers.  The language does not specify whether variables of type `char` are signed or unsigned quantities.  When `char` is converted to an `int`, can it ever produce a negative number?  The answer varies from machine to machine, reflecting differences in architecture.  On some machines a `char` whose leftmost bit is 1 will be converted to a negative integer ("sign extension").  On others, a `char` is promoted to an `int` by adding zeros at the left end, and thus is always positive.
		-- K & R, 2nd Edition, ch 2, p 43-44
%
The definition of C guarantees that any character in the machine's standard printing character set will never be negative, so these characters will always be positive quantities in expressions.  But arbitrary bit patterns stored in character variables may appear to be negative on some machines, yet positive on others.  For portability, specify `signed` or `unsigned` if non-character data is to be stored in `char` variables.
		-- K & R, 2nd Edition, ch 2, p 44
%
Implicit arithmetic conversions work much as expected.  In general, if an operator like + or * that takes two operands (a binary operator) has operands of different types, the "lower" type is promoted to the "higher" type before the operation proceeds.  The result is of the higher type.
		-- K & R, 2nd Edition, ch 2, p 44
%
Since an argument of a function call is an expression, type conversions also take place when arguments are passed to functions.  In the absence of a function prototype, `char` and `short` become `int`, and `float` becomes `double`.
		-- K & R, 2nd Edition, ch 2, p 45
%
[E]xplicit type conversions can be forced ("coerced") in any expression, with a unary operator called a cast.  In the construction

	(type-name) expression

the expression is converted to the named type by the conversion rules[.]
		-- K & R, 2nd Edition, ch 2, p 45
%
The cast operator has the same high precedence as other unary operators[.]
		-- K & R, 2nd Edition, ch 2, p 45
%
If arguments are declared by a function prototype, as they normally should be, the declaration causes automatic coercion of any arguments when the function is called.  Thus, given a function prototype for `sqrt`:

	double sqrt(double);

the call

	root2 = sqrt(2);

coerces the integer 2 into the double value 2.0 without any need for a cast.
		-- K & R, 2nd Edition, ch 2, p 45
%
C provides six operators for bit manipulation; these may only be applied to integral operands, that is, `char`, `short`, `int`, and `long`, whether signed or unsigned.
		-- K & R, 2nd Edition, ch 2, p 48
%
The bitwise AND operator & is often used to mask off some set of bits; for example,

	n = n & 0177;

sets to zero all but the low-order 7 bits of n.
The bitwise OR operator | is used to turn bits on:

	x = x | SET_ON;

sets to one in x the bits that are set to one in SET_ON.
		-- K & R, 2nd Edition, ch 2, p 48
%
Right shifting an `unsigned` quantity always fills vacated bits with zero.  Right shifting a signed quantity will fill with sign bits ("arithmetic shift") on some machines and with 0-bits ("logical shifts") on others.
		-- K & R, 2nd Edition, ch 2, p 49
%
The operator += is called an 'assignment operator.'
		-- K & R, 2nd Edition, ch 2, p 50
%
	x *= y + 1

means

	x = x * (y + 1)

rather than

	x = x * y + 1
		-- K & R, 2nd Edition, ch 2, p 50
%
Declaring the argument `x` to be `unsigned` ensures that when it is right-shifted, vacated bits will be filled with zeros, not sign bits, regardless of the machine the program is run on.
		-- K & R, 2nd Edition, ch 2, p 50
%
[T]he expression `i += 2` is preferable to `i = i + 2`.
		-- K & R, 2nd Edition, ch 2, p 51
%
[A]n assignment operator may even help a compiler to produce efficient code.
		-- K & R, 2nd Edition, ch 2, p 51
%
