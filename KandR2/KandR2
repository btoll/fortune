The model of input and output supported by the standard library is very simple.  Text input or output, regardless of where it originates or where it goes to, is dealt with as streams of characters.  A text stream is a sequence of characters divided into lines; each line consists of zero or more characters followed by a newline character.  It is the responsibility of the library to make each input or output stream conform to this model; the C programmer using the library need not worry about how lines are represented outside of the program.
        -- K & R, 2nd, Edition, ch 1, p 15
%
The body of this for loop is empty, because all of the work is done in the test and increment parts.  But the grammatical rules of C require that a for statement have a body.  The isolated semicolon, called a `null statement`, is there to satisfy that requirement.  We put it on a separate line to make it visible.
		-- K & R, 2nd Edition, ch 1, p 19
%
A character written between single quotes represents an integer value equal to the numerical value of the character in the machine's character set.  This is called a `character constant`, although it is just another way to write a small integer.
		-- K & R, 2nd Edition, ch 1, p 19
%
By definition, chars are just small integers, so char variables and constants are identical to ints in arithmetic expressions.
        -- K & R, 2nd Edition, ch 1, p 23
%
We will generally use `parameter` for a variable named in the parenthesized list in a function definition, and `argument` for the value used in a call of the function.  The terms `formal argument` and `actual argument` are sometimes used for the same distinction.
		-- K & R, 2nd Edition, ch 1, p 25
%
[P]rograms should return status to their environment.
		-- K & R, 2nd Edition, ch 1, p 26
%
Well-chosen names are good documentation.
		-- K & R, 2nd Edition, ch 1, p 26
%
In C, all function arguments are passed "by value."  This means that the called function is given the values of its arguments in temporary variables rather than the originals...[T]he called function cannot directly alter a variable in the calling function; it can only alter its private, temporary copy.
		-- K & R, 2nd Edition, ch 1, p 27
%
When the name of an array is used as an argument, the value passed to the function is the location or address of the beginning of the array -- there is no copying of array elements.  By subscripting this value, the function can access and alter any element of the array.
		-- K & R, 2nd Edition, ch 1, p 28
%
The purpose of supplying the size of an array in a declaration is to set aside storage.
		-- K & R, 2nd Edition, ch 1, p 30
%
Each local variable in a function comes into existence only when the function is called, and disappears when the function is exited.  This is why such variables are known as `automatic` variables, following terminology in other languages.  We will use the term automatic henceforth to refer to these local variables.
		-- K & R, 2nd Edition, ch 1, p 31
%
[C]ommon practice is to place definitions of all external variables at the beginning of the source file, and then omit all `extern` declarations.
		-- K & R, 2nd Edition, ch 1, p 33
%
If the program is in several source files, and a variable is defined in `file1` and used in `file2` and `file3`, then `extern` declarations are needed in `file2` and `fil` to connect the occurrences of the variable.  The usual practice is to collect `extern` declarations of variables and functions is a separate file, historically called a `header`, that is included by `#include` at the beginning of each source file.  The suffix `.h` is conventional for header names.
		-- K & R, 2nd Edition, ch 1, p 33
%
Relying too heavily on external variables is fraught with peril since it leads to programs whose data connections are not at all obvious -- variables can be changed in unexpected and even inadvertent ways, and the program is hard to modify.
		-- K & R, 2nd Edition, ch 1, p 34
%
The type of an object determines the set of values it can have and what operations can be performed on it.
		-- K & R, 2nd Edition, ch 2, p 35
%
Names are made up of letters and digits; the first character must be a letter...[d]on't begin variables names with underscore, however, since library routines often use such names...[t]raditional C practice is to use lower case for variable names, and all upper case for symbolic constants.
		-- K & R, 2nd Edition, ch 2, p 35
%
At least the first 31 characters of an internal name are significant.  For function names and external variables, the number may be less than 31, because external names may be used by assemblers and loaders over which the language has no control.  For external names, the standard guarantees uniqueness only for 6 characters and a single case.
		-- K & R, 2nd Edition, ch 2, p 35
%
There are only a few basic data types in C:

	char	a single byte, capable of holding one character
		in the local character set.
	int	an integer, typically reflecting the natural size
		of integers on the host machine.
	float	single-precision floating point.
	double	double-precision floating point.

In addition, there are a number of qualifiers that can be applied to these basic types.  `short` and `long` apply to integers:

	short int sh;
	long int counter;

The word `int` can be omitted in such declarations, and typically is.
	-- K & R, 2nd Edition, ch 2, p 36
%
Each compiler is free to choose appropriate sizes [of integers] for its own hardware, subject only to the restriction that `short`s and `int`s are at least 16 bits, `long`s are at least 32 bits, and `short` is no longer than `int`, which is no longer than `long`.
		-- K & R, 2nd Edition, ch 2, p 35
%
The qualifer `signed` or `unsigned` may be applied to `char` or any integer.  `unsigned` numbers are always positive or zero, and obey the laws of arithmetic modulo 2^n, where `n` is the number of bits in the type.  So, for instance, if `chars` are 8 bits, `unsigned char` variables have values between 0 and 255, while `signed chars` have values between -128 and 127 (int a two's-complement machine).  Whether plain `chars` are signed or unsigned is machine-dependent, but printable characters are always positive.
		-- K & R, 2nd Edition, ch 2, p 36
%
An integer constant like 1234 is an `int`.  A long constant is written with a terminal `l` (ell) or `L`, as in 123456789L; an integer too big to fit into an `int` will also be taken as a `long`.  Unsigned constants are written with a terminal `u` or `U`, and the suffix `ul` or `UL` indicates `signed long`.
		-- K & R, 2nd Edition, ch 2, p 37
%
Floating-point constants contain a decimal point (123.4) or an exponent (1e-2) or both; their type is `double`, unless suffixed.  The suffixes `f` or `F` indicate a `float` constant; `l` or `L` indicate a `long double`.
		-- K & R, 2nd Edition, ch2, p 37
%
The value of an integer can be specified in octal or hexadecimal instead of decimal.  A leading zero (0) on an integer constant means octal; a leading 0x or 0X means hexadecimal...Octal and hexadecimal constants may also be followed by `L` to make them `long` and `U` to make them unsigned (ed. note -- i.e., 0XFUL).
		-- K & R, 2nd Edition, ch 2, p 37
%
A character constant is an integer, written as one character within single quotes, such as 'x'.  The value of a character constant is the numeric value of the character in the machine's character set.  For example, in the ASCII character set the character constant '0' has the value 48, which is unrelated to the numeric value 0.
		-- K & R, 2nd Edition, ch 2, p 37
%
Certain characters can be represented in character and string constants by escape sequences like \n (newline); these sequences look like two characters, but represent only one.  In addition, an arbitrary byte-sized bit pattern can be specified by

	'\ooo'

where `ooo` is one to three octal digits (0...7) or by

	'\xhh'

where `hh` is one or more hexadecimal digits (0...9, a...f, A...F).  So we might write

	#define VTAB '\013'	/* ASCII vertical tab */
	#define BELL '\007'	/* ASCII bell character */

or, in hexadecimal,

	#define VTAB '\xb'	/* ASCII vertical tab */
	#define BELL '\x7'	/* ASCII bell character */
		-- K & R, 2nd Edition, ch 2, p 37-38
%
The character constant '\0' represents the character with value zero, the null character.  '\0' is often written instead of 0 to emphasize the character nature of some expressio but the numeric value is just 0.
		-- K & R, 2nd Editionk, ch 2, p 38
%
String constants can be concatenated at compile time:

	"hello," " world"

is equivalent to

	"hello, world"

This is useful for splitting long strings across several source lines.
		-- K & R, 2nd Edition, ch 2, p 38
%
Technically, a string constant is an array of characters.  The internal representation of a string has a null character '\0' at the end, so the physical storage required is one more than the number of characters written between the quotes.  This representation means that there is no limit to how long a string can be[.]
		-- K & R, 2nd Edition, ch 2, p 38
%
There is one other kind of constant, the enumeration constant.  An enumeration is a list of constant integer values, as in

	enum boolean { NO, YES };

The first name in an `enum` has value 0, the next 1, and so on, unless explicit values are specified.  If not all values are specified, unspecified values continue the progression from the last specified value...Names in different enumerations must be distinct.  Values need not be distinct in the same enumeration.
		-- K & R, 2nd Edition, ch 2, p 39
%
Enumerations provide a convenient way to associate constant values with names, an alternative to `#define` with the advantage that the values can be generated for you.  Although variables of `enum` types may be declared, compilers need not check that what you store in such a variable is a valid value for the enumeration.  Nevertheless, enumeration variables offer the chance of checking and so are often better then `#define`s.  In addition, a debugger may be able to print values of enumeration variables in their symbolic form.
		-- K & R, 2nd Edition, ch 2, p 39
%
External and static variables are initialized to zero by default.  Automatic variables for which there is no explicit initializer have undefined (i.e., garbage) values.
		-- K & R, 2nd Edition, ch 2, p 40
%
The qualifier `const` can be applied to the declaration of any variable to specify that its value will not be changed.  For an array, the `const` qualifier says that the elements will not be altered...The `const` declaration can also be used with array arguments, to indicate that the function does not change the array:

    int strlen(const char[]);
		-- K & R, 2nd Edition, ch 2, p 40
%
The binary + and - operators have the same precedence, which is lower than the precedence of *, /, and %, which is in turn lower than unary + and -.  Arithmetic operators associate left to right.
		-- K & R, 2nd Edition, ch 2, p 41
%
The relational operators are

	>	>=	<	<=

They all have the same precedence.  Just below them in precedence are the equality operators:

	==	!=

Relational operators have lower precedence than arithmetic operators, so an expression like `i < lim-1` is taken as `i < (lim-1)`, as would be expected.
		-- K & R, 2nd Edition, ch 2, p 41
%
The precedence of && is higher than ||, and both are lower than relational and equality operators, so expressions like

	i<lim-1 && (c = getchar()) != '\n' && c != EOF

need no extra parentheses.
		-- K & R, 2nd Edition, ch 2, p 42
%
By definition, the numeric value of a relational or logical expression is 1 if the relation is true, and 0 if the relation is false.
		-- K & R, 2nd Edition, ch 2, p 42
%
The unary negation operator ! converts a non-zero operand into 0, and a zero operand into a 1.
		-- K & R, 2nd Edition, ch 2, p 42
%
When an operator has operands of different types, they are converted to a common type according to a small number of rules.  In general, the only automatic conversions are those that convert a "narrower" operand into a "wider" one without losing information, such as converting an interger to a floating point in an expression like `f + i`.  Expressions that don't make sense, like using a `float` as a subscript, are disallowed.  Expressions that might lose information, like assigning a longer integer type to a shorter, or a floating-point type to an integer, may draw a warning, but they are not illegal.
		-- K & R, 2nd Edition, ch 2, p 42
%
There is one subtle point about the conversion of characters to integers.  The language does not specify whether variables of type `char` are signed or unsigned quantities.  When `char` is converted to an `int`, can it ever produce a negative number?  The answer varies from machine to machine, reflecting differences in architecture.  On some machines a `char` whose leftmost bit is 1 will be converted to a negative integer ("sign extension").  On others, a `char` is promoted to an `int` by adding zeros at the left end, and thus is always positive.
		-- K & R, 2nd Edition, ch 2, p 43-44
%
The definition of C guarantees that any character in the machine's standard printing character set will never be negative, so these characters will always be positive quantities in expressions.  But arbitrary bit patterns stored in character variables may appear to be negative on some machines, yet positive on others.  For portability, specify `signed` or `unsigned` if non-character data is to be stored in `char` variables.
		-- K & R, 2nd Edition, ch 2, p 44
%
Implicit arithmetic conversions work much as expected.  In general, if an operator like + or * that takes two operands (a binary operator) has operands of different types, the "lower" type is promoted to the "higher" type before the operation proceeds.  The result is of the higher type.
		-- K & R, 2nd Edition, ch 2, p 44
%
Since an argument of a function call is an expression, type conversions also take place when arguments are passed to functions.  In the absence of a function prototype, `char` and `short` become `int`, and `float` becomes `double`.
		-- K & R, 2nd Edition, ch 2, p 45
%
[E]xplicit type conversions can be forced ("coerced") in any expression, with a unary operator called a cast.  In the construction

	(type-name) expression

the expression is converted to the named type by the conversion rules[.]
		-- K & R, 2nd Edition, ch 2, p 45
%
The cast operator has the same high precedence as other unary operators[.]
		-- K & R, 2nd Edition, ch 2, p 45
%
If arguments are declared by a function prototype, as they normally should be, the declaration causes automatic coercion of any arguments when the function is called.  Thus, given a function prototype for `sqrt`:

	double sqrt(double);

the call

	root2 = sqrt(2);

coerces the integer 2 into the double value 2.0 without any need for a cast.
		-- K & R, 2nd Edition, ch 2, p 45
%
C provides six operators for bit manipulation; these may only be applied to integral operands, that is, `char`, `short`, `int`, and `long`, whether signed or unsigned.
		-- K & R, 2nd Edition, ch 2, p 48
%
The bitwise AND operator & is often used to mask off some set of bits; for example,

	n = n & 0177;

sets to zero all but the low-order 7 bits of n.
The bitwise OR operator | is used to turn bits on:

	x = x | SET_ON;

sets to one in x the bits that are set to one in SET_ON.
		-- K & R, 2nd Edition, ch 2, p 48
%
Right shifting an `unsigned` quantity always fills vacated bits with zero.  Right shifting a signed quantity will fill with sign bits ("arithmetic shift") on some machines and with 0-bits ("logical shifts") on others.
		-- K & R, 2nd Edition, ch 2, p 49
%
The operator += is called an 'assignment operator.'
		-- K & R, 2nd Edition, ch 2, p 50
%
	x *= y + 1

means

	x = x * (y + 1)

rather than

	x = x * y + 1
		-- K & R, 2nd Edition, ch 2, p 50
%
Declaring the argument `x` to be `unsigned` ensures that when it is right-shifted, vacated bits will be filled with zeros, not sign bits, regardless of the machine the program is run on.
		-- K & R, 2nd Edition, ch 2, p 50
%
[T]he expression `i += 2` is preferable to `i = i + 2`.
		-- K & R, 2nd Edition, ch 2, p 51
%
[A]n assignment operator may even help a compiler to produce efficient code.
		-- K & R, 2nd Edition, ch 2, p 51
%
[T]the type of an assignment expression is the type of its left operand, and the value is the value after assignment.
		-- K & R, 2nd Edition, ch 2, p 51
%
The conditional expression, written with the ternary operator "?:", provides an alternate way to write [an if/else block] and similar constructions.
		-- K & R, 2nd Edition, ch 2, p 51
%
Parentheses are not necessary around the first expression of a conditional expression, since the precedence of ?: is very low, just above assignment.  They are advisable anyway, however, since they make the condition part of the expression easier to see.
		-- K & R, 2nd Edition, ch 2, p 52
%
C, like most languages, does not specify the order in which the operands of an operator are evaluated. (The exceptions are &&, ||, ?:, and ','.)
		-- K & R, 2nd Edition ch 2, p 52
%
[T]he order in which function arguments are evaluated is not specified, so the statement

	printf("%d %d\n", ++n, power(2, n));	/* WRONG */

can produce different results with different compilers, depending on whether `n` is incremented before `power` is called.  The solution, of course, is to write

	++n;
	printf("%d %d\n", n, power(2, n));
		-- K & R, 2nd Edition, ch 2, p 53
%
Function calls, nested assignment statements, and increment and decrement operators cause "side effects" -- some variable is changed as a by-product of the evaluation of an expression.  In any expression involving side effects, there can be subtle dependencies on the order in which variables taking part in the expression are updated.
		-- K & R, 2nd Edition, ch 2, p 53
%
Compilers can interpret [the order in which expressions are evaluated] in different ways, and generate different answers depending on their interpretation.  The standard intentionally leaves most such matters unspecified.  When side effects (aignment to variables) take place within an expression is left to the discretion of the compiler, since the best order depends strongly on machine architecture.
		-- K & R, 2nd Edition, ch 2, p 54
%
The moral is that writing code that depends on order of evaluation is a bad programming practice in any language.  Naturally, it is necessary to know what things to avoid, but if you don't know how they are done on various machines, you won't be tempted to take advantage of a particular implementation.
		-- K & R, 2nd Edition, ch 2, p 54
%
In C, the semicolon is a statement terminator, rather than a separator as it is in languages like Pascal.
		-- K & R, 2nd Edition, ch 3, p 55
%
Braces { and } are used to group declarations and statements together into a compound statement, or block, so that they are syntactically equivalent to a single statement.
		-- K & R, 2nd Edition, ch 3, p 55
%
[I]t's a good idea to use braces when there are nested `if`s.
		-- K & R, 2nd Edition, ch 3, p 56
%
`break` and `return` are the most common ways to leave a `switch`.  A `break` statement can also be used to force and immediate exit from `while`, `for`, and `do` loops[.]
		-- K & R, 2nd Edition, ch 3, p 59
%
As a matter of good form, put a `break` after the last case [in a `switch`] even though it's logically unnecessary.  Some day when another case gets added at the end, this bit of defensive programming will save you.
		-- K & R, 2nd Edition, ch3, p 59
%
The `for` statement

	for (expr1; expr2; expr3)
		statement

is equivalent to

	expr1;
	while (expr2) {
        statement
        expr3;
	}

except for the behavior of `continue`[.]
		-- K & R, 2nd Edition, ch 3, p 60
%
Grammatically, the three components of a `for` loop are expressions.  Most commonly, expr1 and expr3 are assignments or function calls and expr2 is a relational expression.  Any of the three parts [of a `for` loop] can be omitted, although the semi-colons must remain.  If expr1 or expr3 is omitted, it is simply dropped from the expansion.  If the test, expr2, is not present, it is taken as permanently true, so

	for (;;) {
        ...
	}

is an "infinite" loop, presumably to be broken by other means, such as a `break` or `return`.
		-- K & R, 2nd Edition, ch 3, p 60
%
Whether to use `while` or `for` is largely a matter of personal preference...The `for` is preferable when there is a simple initialization and increment, since it keeps the loop control statments close together and visible at the top of the loop.
		-- K & R, 2nd Edition, ch 3, p 60-61
%
Because the components for the `for` are arbitrary expressions, `for` loops are not restricted to arithmetic progressions.  Nonetheless, it is bad style to force unrelated computation into the initialization and increment of a `for`, which are better reserved for loop control operations.
		K & R, 2nd Edition, ch 3, p 61
%
One final C operator is the comma ",", which most often finds use in the `for` statement.  A pair of expressions separated by a comma is evaluated left to right, and the type and value of the result are the type and value of the right operand.
		-- K & R, 2nd Edition, ch 3, p 62
%
The commas that separate function arguments, variables in declarations, etc., are not comma operators, and do not guarantee left to right evaluation.
		-- K & R, 2nd Edition, ch 3, p 63
%
Comma operators should be used sparingly.  The most suitable uses are for constructs strongly related to each other, as in the `for` loop, and in macros where a multistep computation has to be a single expression.
		-- K & R, 2nd Edition, ch 3, p 63
%
[T]he third loop in C, the `do-while`, tests at the bottom after making each pass through the loop body; the body is always executed at least once.  The syntax of the `do` is

    do
        statement
    while (expression);
		-- K & R, 2nd Edition, ch 3, p 63
%
The `break` statement provides an early exit from `for`, `while`, and `do`, just as from `switch`.  A `break` causes the innermost enclosing loop or `switch` to be exited immediately.
		-- K & R, 2nd Edition, ch 3, p 64
%
The `continue` statement is related to `break`, but less often used; it causes the next iteration of the enclosing `for`, `while`, or `do` loop to begin.  In the `while` and `do`, this means that the test part is executed immediately; in the `for`, control passes to the increment step.  The `continue` statement applies only to loops, not to `switch`.  A `continue` inside a `switch` inside a loop causes the next loop iteration.
		-- K & R, 2nd Edition, ch 3, p 65
%
C provides the infinitely-abusable `goto` statement, and labels to branch to.  Formally, the `goto` is never necessary, and in practice it is almost always easy to write code without it.  We have not used `goto` in this book.
Nevertheless, there are a few situations where `goto`s may find a place.  The most common is to abandon processing in some deeply nested structure, such as breaking out of two or more loops at once.  The `break` statement cannot be used directly since it only exits from the innermost loop.
		-- K & R, 2nd Edition, ch 3, p 65
%
    for ( ... )
        for ( ... ) {
            ...
            if (disaster)
                goto error;
        }
    ...

error:
    clean up the mess
		-- K & R, 2nd Edition, ch 3, p 66
%
A label has the same form as a variable name, and is followed by a colon.  It can be attached to any statement in the same function as the `goto`.  The scope of a label is the entire function.
		-- K & R, 2nd Edition, ch 3, p 66
%
Code involving a `goto` can always be written without one though perhaps at the price of some repeated tests or an extra variable.  With a few exceptions, code that relies on `goto` statements is generally harder to understand and to maintain than code without `goto`s.  Although we are not dogmatic about the matter, it does seem that `goto` statements should be used rarely, if at all.
		-- K & R, 2nd Edition, ch 3, p 66
%
Function declaration and definition is the area where the ANSI standard has made the most visible changes to C...The syntax of function definition also changes, so that declarations and defintions match.  This makes it possible for a compiler to detect many more errors than it could before.  Furthermore, when arguments are properly declared, appropriate type coercions, are performed automatically.
		-- K & R, 2nd Edition, ch 4, p 67
%
Each function definition has the form

    return-type function-name(argument declarations)
    {
        declarations and statements
    }

Various parts may be absent; a minimal function is

    dummy() {}

which does nothing and returns nothing.  A do-nothing function like this is sometimes useful as a place holder during program development.  If the return type is omitted, `int` is assumed.
		-- K & R, 2nd Edition, ch 4, p 69-70
%
The `return` statement is the mechanism for returning a value from the called function to its caller.  Any expression can follow `return`:

    return expression;

The expression will be converted to the return type of the function if necessary.  Parentheses are often used around the expression, but they are optional.
		-- K & R, 2nd Edition, ch 4, p 70
%
The calling function is free to ignore the returned value.  Furthermore, there need be no expression after `return`; in that case, no value is returned to the caller.  Control also returns to the caller with no value when execution "falls off the end" of the function by reaching the closing right brace.  It is not illegal, but probably a sign of trouble, if a function returns a value from one place and no value from another.  In any case, if a function fails to return a value, its "value" is certain to be garbage.
		-- K & R, 2nd Edition, ch 4, p 70
%
If there is an error, say in main.c, that file can be recompiled by itself and the result loaded with the previous object files, with the command

    cc main.c getline.o strindex.o

The `cc` command uses the ".c" versus ".o" naming convention to distinguish source files from object files.
		-- K & R, 2nd Edition, ch 4, p 70-71
%
The declaration

    double sum, atof(char []);

says that `sum` is a `double` variable, and that `atof` is a function that takes one `char[]` argument and returns a `double`.
		-- K & R, 2nd Edition, ch 4, p 72
%
In the light of what we have said about how declarations must match definitions, this might seem surprising.  The reason a mismatch can happen is that if there is no function prototype, a function is implicitly declared by its first appearance in an expression, such as

    sum += atof(line)

If a name that has not been previously declared occurs in an expression and is followed by a left parenthesis, it is declared by context to be a function name, the function is assumed to return an `int`, and nothing is assumed about its arguments.  Furthermore, if a function declaration does not incluce arguments, as in

    double atof();

that too is taken to mean that nothing is to be assumed about the arguments of `atof`; all parameter checking is turned off.  This special meaning of the empty argument list is intended to permit older C programs to compile with new compilers.  But it's a bad idea to use it with new programs.  If the function takes arguments, declare them; if it takes no arguments, use `void`.
		-- K & R, 2nd Edition, ch 4, p 72-73
%
Given `atof` properly declared, we could write `atoi` (convert a string to `int`) in terms of it:

    /* atoi:  convert string s to integer using atof */
    int atoi(char [])
    {
        double atof(char s[]);

        return (int) atof(s);
    }

This operation does potentially discard information, however, so some compilers warn of it.  The cast states explicitly that the operation is intended, and suppresses any warning.
		-- K & R, 2nd Edition, ch 4, p 73
%
A C program consists of a set of external objects, which are either variables or functions.  The adjective "external" is used in contrast to "internal," which describes the arguments and variables defined inside functions.  External variables are defined outside of any function, and are thus potentially available to many functions.  Functions themselves are always external, because C does not allow functions to be defined inside other functions.
		-- K & R, 2nd Edition, ch 4, p 73
%
By default, external variables and functions have the property that all references to them by the same name, even from functions compiled separately, are references to the same thing.  (The standard calls this property external linkage)
		-- K & R, 2nd Edition, ch 4, p 73
%
Because external variables are globally accessible, they provide an alternative to function arguments and return values for communicating data between functions.  Any function may access an external variable by referring to it by name, if the name has been declared somehow.
		-- K & R, 2nd Edition, ch 4, p 74
%
External variables are also useful because of their greater scope and lifetime.  Automatic variables are internal to a function; they come into existence when the function is entered, and disappear when it is left.  External variables, on the other hand, are permanent, so they retain values from one function invocation to the next.
		-- K & R, 2nd Edition, ch 4, p 74
%
Because + and * are commutative operators, the order in which the popped operands are combined is irrelevant, but for - and / the left and right operands must be distinguished.  In

	push(pop() - pop());	/* WRONG */

the order in which the two calls of `pop` are evaluated is not defined.  To guarantee the right order it is necessary to pop the first value into a temporary variable as we did in `main`.
		-- K & R, 2nd Edition, ch 4, p 77
%
The scope of a name is the part of the program within which the name can be used.  For an automatic variable declared at the beginning of a function, the scope is the function in which the name is declared.
		-- K & R, 2nd Edition, ch 4, p 80
%
The scope of an external variable or a function lasts from the point at which it is declared to the end of the file being compiled.
		-- K & R, 2nd Edition, ch 4, p 80
%
[I]f an external variable is to be referred to before it is defined, or if it is defined in a different source file from the one where it is being used, then an `extern` declaration is mandatory.
		-- K & R, 2nd Edition, ch 4, p 80
%
It is important to distinguish between the declaration of an external variable and its definition.  A declaration announces the properties of a variable (primarily its type); a definition also causes storage to be set aside.
		-- K & R, 2nd Edition, ch 4, p 80
%
There must be only one definition of an external variable among all the files that make up the source program; other files may contain `extern` declarations to access it.  (There may also be `extern` declarations in the file containing the definition.)  Array sizes must be specified with the definition, but are optional with an `extern` declaration.
		-- K & R, 2nd Edition, ch 4, p 81
%
There is a tradeoff between the desire that each file have access only to the information it needs for its job and the practical reality that it is harder to maintain more header files.  Up to some moderate program size, it is probably best to have one header file that contains everything that is to be shared between any two parts of the program; that is the decision we made here.  For a much larger program, more organization and more headers would be needed.
		-- K & R, 2nd Edition, ch 4, p 82
%
The `static` declaration, applied to an external variable or function, limits the scope of that object to the rest of the source file being compiled.
		-- K & R, 2nd Edition, ch 4, p 83
%
The external `static` declaration is most often used for variables, but it can be applied to functions as well.  Normally, function names are global, visible to any part of the entire program.  If a function is declared `static`, however, its name is invisible outside of the file in which it is declared.
		-- K & R, 2nd Edition, ch 4, p 83
%
The `static` declaration can also be applied to internal variables.  Internal `static` variables are local to a particular function just as automatic variables are, but unlike automatics, they remain in existence rather than coming and going each time the function is activated.  This means that internal `static` variables provide private, permanent storage within a single function.
		-- K & R, 2nd Edition, ch 4, p 83
%
A `register` declaration advises the compiler that the variable in question will be heavily used.  The idea is that `register` variables are to be placed in machine registers, which may result in smaller and faster programs.  But compilers are free to ignore the advice.
		-- K & R, 2nd Edition, ch 4, p 83
%
The `register` declaration looks like

    register int x;
    register char c;

and so on.  The `register` declaration can only be applied to automatic variables and to the formal parameters of a function.  In this latter case, it looks like

    f(register unsigned m, register long n)
    {
        register int i;
        ...
    }
		-- K & R, 2nd Edition, ch 4, p 83-84
%
In practice, there are restrictions on register variables, reflecting the realities of underlying hardware.  Only a few variables in each function may be kept in registers, and only certain types are allowed.  Excess register declarations are harmless, however, since the word `register` is ignored for excess or disallowed declarations.  And it is not possible to take the address of a register variable, regardless of whether the variable is actually placed in a register.  The specific restrictions on number and types of register variables vary from machine to machine.
		-- K & R, 2nd Edition, ch 4, p 84
%
An automatic variable declared and initialized in a block is initialized each time the block is entered.  A `static` variable is initialized only the first time the block is entered.
		-- K & R, 2nd Edition, ch 4, p 84
%
As a matter of style, it's best to avoid variable names that conceal names in an outer scope; the potential for confusion and error is too great.
		-- K & R, 2nd Edition, ch 4, p 85
%
In the absence of explicit initialization, external and static variables are guaranteed to be initialized to zero; automatic and register variables have undefined (i.e., garbage) initial values.
		-- K & R, 2nd Edition, ch 4, p 85
%
For automatic and register variables, the initializer is not restricted to being a constant:  it may be any expression involving previously defined values, even function calls.
		-- K & R, 2nd Edition, ch 4, p 85
%
In effect, initializations of automatic variables are just shorthand for assignment statements.  Which form to prefer is largely a matter of taste.  We have generally used explicit assignments, because initializers in declarations are harder to see and further away from the point of use.
		-- K & R, 2nd Edition, ch 4, p 86
%
If there are fewer initializers for an array than the number specified, the missing elements will be zero for external, static, and automatic variables.  It is an error to have too many initializers.  There is no way to specify repetition of an initializer, nor to initialize an element in the middle of an array without supplying all the preceding values as well.
		-- K & R, 2nd Edition, ch 4, p 86
%
Character arrays are a special case of initialization; a string may be used instead of the braces and commas notation:

    char pattern[] = "ould";

is a shorthand for the longer but equivalent

    char pattern[] = { 'o', 'u', 'l', 'd', '\0' };

In this case, the array size is five (four characters plus the terminating '\0').
		-- K & R, 2nd Edition, ch 4, p 86
%
When a function calls itself recursively, each invocation gets a fresh set of all the automatic variables, independent of the previous set.
		-- K & R, 2nd Edition, ch 4, p 87
%
Recursion may provide no saving in storage, since somewhere a stack of the values being processed must be maintained.  Nor will it be faster.  But recursive code is more compact, and often much easier to write and understand than the non-recursive equivalent.  Recursion is especially convenient for recursively defined data structures like trees[.]
		-- K & R, 2nd Edition, ch 4, p 88
%
C provides certain language facilities by means of a preprocessor, which is conceptually a separate first step in compilation.  The two most frequently used features are `#include`, to include the contents of a file during compilation, and `#define`, to replace a token by an arbitrary sequence of characters.
		-- K & R, 2nd Edition, ch 4, p 88
%
If the filename is quoted, searching for the file typically begins where the source program was found; if it is not found there, or if the name is enclosed in < and >, searching follows an implementation-defined rule to find the file.
		-- K & R, 2nd Edition, ch 4, p 88
%
`#include` is the preferred way to tie the declarations together for a large program.  It guarantees that all the source files will be supplied with the same definitions and variable declarations, and thus eliminates a particularly nasty kind of bug.  Naturally, when an included file is changed, all files that depend on it must be recompiled.
		-- K & R, 2nd Edition, ch 4, p 89
%
The scope of a name defined with `#define` is from its point of definition to the end of the source file being compiled.
		-- K & R, 2nd Edition, ch 4, p 89
%
Any name may be defined with any replacement text.  For example,

    #define forever for (;;)    /* infinite loop */

defines a new word, `forever`, for an infinite loop.
		-- K & R, 2nd Edition, ch 4, p 89
%
It is also possible to define macros with arguments, so the replacement text can be different for different calls of the macro.  As an example, define a macro called `max`:

    #define max(A, B)   ((A) > (B) ? (A) : (B))

Although it looks like a function call, a use of `max` expands into in-line code.  Each occurrence of an formal character (here `A` or `B`) will be replaced by the corresponding actual argument.  Thus the line

    x = max(p+q, r+s);

will be replaced by the line

    x = ((p+q) > (r+s) ? (p+q) : (r+s));

So long as the arguments are treated consistently, this macro will serve for any data type; there is no need for different kinds of `max` for different data types, as there would be with functions.
		-- K & R, 2nd Edition, ch 4, p 89-90
%
Names may be undefined with `#undef`, usually to ensure that a routine is really a function, not a macro[.]
		-- K & R, 2nd Edition, ch 4, p 90
%
The preprocessor operator ## provides a way to concatenate actual arguments during macro expansion.  If a parameter in the replacement text is adjacent to a ##, the parameter is replaced by the actual argument, the ## and surrounding whitespace are removed, and the result is re-scanned.
		-- K & R, 2nd Edition, ch 4, p 90
%
It is possible to control preprocessing itself with conditional statements that are evaluated during preprocessing.  This provides a way to include code selectively, depending on the value of conditions evaluated during compilation.
		-- K & R, 2nd Edition, ch 4, p 91
%
A pointer is a variable that contains the address of a variable.
		-- K & R, 2nd Edition, ch 5, p 93
%
[T]he type `void *` (pointer to `void`) replaces `char *` as the proper type for a generic pointer.
		-- K & R, 2nd Edition, ch 5, p 93
%
The unary operator `&` gives the address of an object, so the statement

    p = &c;

assigns the address of `c` to the variable `p`, and `p` is said to "point to" `c`.  The & operator only applies to objects in memory: variables and array elements.  It cannot be applied to expressions, constants, or `register` variables.
		-- K & R, 2nd Edition, ch 5, p 93-94
%
The unary operator `*` is the indirection or dereferencing operator; when applied to a pointer, it accesses the object the pointer points to.
		-- K & R, 2nd Edition, ch 5, p 94
%
You should also note the implication that a pointer is constrained to point to a particular kind of object: every pointer points to a specific data type.  (There is one exception: a "pointer to void" is used to hold any type of pointer but cannot be dereferenced itself.)
		-- K & R, 2nd Edition, ch 5, p 94
%
The unary operators * and & bind more tightly than arithmetic operators, so the assignment

    y = *ip + 1

takes whatever `ip` points at, adds 1, and assigns the result to `y`, while

    *ip += 1

increments what `ip` points to, as do

    ++*ip

and

    (*ip)++

The parentheses are necessary in this last example; without them, the expression would increment`ip` instead of what it points to, because unary operators like * and ++ associate right to left.
		-- K & R, 2nd Edition, ch 5, p 94-95
%
Since C passes arguments to functions by value, there is no direct way for the called function to alter a variable in the calling function...[t]he way to obtain the desired effect is for the calling program to pass pointers to the values to be changed:

    swap(&a, &b)

Since the operator & produces the address of a variable, `&a` is a pointer to `a`.  In `swap` itself, the parameters are declared to be pointers, and the operands are accessed indirectly through them.
		-- K & R, 2nd Edition, ch 5, p 95
%
In C, there is a strong relationship between pointers and arrays, strong enough that pointers and arrays should be discussed simultaneously.  Any operation that can be achieved by array subscripting can also be done with pointers.  The pointer version will in general be faster but, at least to the uninitiated, somewhat harder to understand.
		-- K & R, 2nd Edition, ch 5, p 97
%
The correspondence between indexing and pointer arithmetic is very close.  By definition, the value of a variable or expression of type array is the address of element zero of the array.  Thus after the assignment

    pa = &a[0];

`pa` and `a` have identical values.  Since the name of an array is a synonym for the location of the initial element, the assignment `pa=&a[0]` can also be written as

    pa = a;
		-- K & R, 2nd Edition, ch 5, p 99
%
Rather more surprising, at least at first sight, is the fact that a reference to `a[i]` can also be written as `*(a+i)`.  In evaluating `a[i]`, C converts it to `*(a+i)` immediately; the two forms are equivalent.  Applying the operator & to both parts of this equivalence, it follows that `&a[i]` and `a+i` are also identical: `a+i` is the address of the i-th element beyond `a`.  As the other side of this coin, if `pa` is a pointer, expressions may use it with a subscript; `pa[i]` is identical to `*(pa+i)`.  In short, and array-and-index expression is equivalent to one written as a pointer and offset.
		-- K & R, 2nd Edition, ch 5, p 99
%
There is one difference between an array name and a pointer that must be kept in mind.  A pointer is a variable, so `pa=a` and `pa++` are legal.  But an array name is not a variable; constructions like `a=pa` and `a++` are illegal.
		-- K & R, 2nd Edition, ch 5, p 99
%
As formal parameters in a function definition,

    char s[];

and

    char *s;

are equivalent; we prefer the latter because it says more explicitly that the parameter is a pointer.  When an array name is passed to a function, the function can at its convenience believe that it has been handed either an array or a pointer, and manipulate it accordingly.  It can even use both notations if it seems appropriate and clear.
		-- K & R, 2nd Edition, ch 5, p 99-100
%
If one is sure that the elements exist, it is also possible to index backwards in an array; `p[-1]`, `p[-2]`, and so on are syntactically legal, and refer to the elements that immediately precede `p[0]`.  Of course, it is illegal to refer to objects that are not within the array bounds.
		-- K & R, 2nd Edition, ch 5, p 100
%
If `p` is a pointer to some element of an array, then `p++` increments `p` to point to the next element, and `p+=i` increments it to point to `i` elements beyond where it currently does.  These and similar constructions are the simplest forms of pointer or address arithmetic.
		-- K & R, 2nd Edition, ch 5, p 100
%
C is consistent and regular in its approach to address arithmetic; its integration of pointers, arrays, and address arithmetic is one of the strengths of the language.
		-- K & R, 2nd Edition, ch 5, p 100
%
In general a pointer can be initialized just as any other variable can, though normally the only meaningful values are zero or an expression involving the addresses of previously defined data of appropriate type.  The declaration

    static char *allocp = allocbuf;

defines `allocp` to be a character pointer and initializes it to point to the beginning of `allocbuf`, which is the next free position when the program starts.  This could have been written

    static char *allocp = &allocbuf[0];

since the array name is the address of the zeroth element.
		-- K & R, 2nd Edition, ch 5, p 102
%
C guarantees that zero is never a valid address for data, so a return value of zero can be used to signal an abnormal event[.]
		-- K & R, 2nd Edition, ch 5, p 102
%
Pointers and integers are not interchangeable.  Zero is the sole exception; the constant zero may be assigned to a pointer, and a pointer may be compared with the constant zero.  The symbolic constant NULL is often used in place of zero, as a mnemonic to indicate more clearly that this is a special value for a pointer.
		-- K & R, 2nd Edition, ch 5, p 102
%
[P]ointers may be compared under certain conditions.  If p and q point to members of the same array, then relations like ==, !=, <, >=, etc., work properly.  For example,

    p < q

is true if p points to an earlier member of the array than q does.  Any pointer can be meaningfully compared for equality or inequality with zero.  But the behavior is undefined for arithmetic or comparisons with pointers that do not point to members of the same array.  (There is one exception: the address of the first element past the end of an array can be used in pointer arithmetic.)
		-- K & R, 2nd Edition, ch 5, p 102-103
%
[W]e have already observed that a pointer and an integer may be added or subtracted.  The construction

    p + n

means the address of the n-th object p points to; n is scaled according to the size of the objects p points to, which is determined by the declaration of p.  If an `int` is four bytes, for example, the `int` will be scaled by four.
		-- K & R, 2nd Edition, ch 5, p 103
%
The valid pointer operations are assignment of pointers of the same type, adding or subtracting a pointer and an integer, subtracting or comparing two pointers to members of the same array, and assigning or comparing to zero.  All other pointer arithmetic is illegal.  It is not legal to add two pointers, or to mulitply or divide or shift or mask them, or to add `float` or `double` to them, or even, except for `void *`, to assign a pointer of one type to a pointer of another type without a cast.
		-- K & R, 2nd Edition, ch 5, p 103
%
A string constant, written as

    "I am a string"

is an array of characters.  In the internal representation, the array is terminated with the null character '\0' so that programs can find the end.  The length in storage is thus one more than the number of characters between the double quotes.
		-- K & R, 2nd Edition, ch 5, p 104
%
There is an important difference between these definitions:

    char amessage[] = "now is the time";    /* an array */
    char *pmessage = "now is the time";     /* a pointer */

`amessage` is an array, just big enough to hold the sequence of characters and '\0' that initializes it.  Individual characters within the array may be changed but `amessage` will always refer to the same storage.  On the other hand, `pmessage` is a pointer, initialized to point to a string constant; the pointer may subsequently be modified to point elsewhere, but the result is undefined if you try to modify the string constents.
		-- K & R, 2nd Edition, ch 5, p 104
%
Since ++ and -- are either prefix or postfix operators, other combinations of * and ++ and -- occur although less frequently.  For example,

    *--p

decrements p before fetching the character that p points to.  In fact, the pair of expressions

    *p++ = val;     /* push val onto stack */
    val = *--p;     /* pop top of stack into val */

are the standard idioms for pushing and popping a stack[.]
		-- K & R, 2nd Edition, ch 5, p 104
%
Since pointers are variables themselves, they can be stored in arrays just as other variables can.
		-- K & R, 2nd Edition, ch 5, p 107
%
In C, a two-dimensional array is really a one-dimensional array, each of whose elements is an array...Elements are stored by rows, so the rightmost subscript, or column, varies fastest as elements are accessed in storage order.
		-- K & R, 2nd Edition, ch 5, p 112
%
An array is initialized by a list of initializers in braces; each row of a two-dimensional array is initialized by a corresponding sub-list.
		-- K & R, 2nd Edition, ch 5, p 112
%
If a two-dimensional array is to be passed to a function, the parameter declaration in the function must include the number of columns; the number of rows is irrelevant, since what is passed is, as before, a pointer to an array of rows...[o]nly the first dimension (subscript) of an array is free; all the others have to be specified.
		-- K & R, 2nd Edition, ch 5, p 112
%
Newcomers to C are sometimes confused about the difference between a two-dimensional array and an array of pointers[.]  Given the definitions

    int a[10][20];
    int *b[10];

then a[3][4] and b[3][4] are both syntactically legal references to a single `int`.  But a is a true two-dimensional array: 200 `int`-sized locations have been set aside, and the conventional rectangular subscript calculation 20xrow+col is used to find the element a[row][col].  For b, however, the definition only allocates 10 pointers and does not initialize them; initialization must be done explicitly, either statically or with code.
		-- K & R, 2nd Edition, ch 5, p 113
%
The important advantage of the pointer array is that the rows of the array may be of different lengths.
		-- K & R, 2nd Edition, ch 5, p 113
%
[B]y far the most frequent use of arrays of pointers is to store character strings of diverse lengths[.]
		-- K & R, 2nd Edition, ch 5, p 114
%
In environments that support C, there is a way to pass command-line arguments or parameters to a program when it begins executing.  When main is called, it is called with two arguments.  The first (conventionally called `argc`, for argument count) is the number of command-line arguments the program was invoked with; the second (`argv`, for argument vector) is a pointer to an array of character strings that contain the arguments, one per string.
		-- K & R, 2nd Edition, ch 5, p 114
%
By convention, argv[0] is the name by which the program was invoked, so argc is at least 1.  If argc is 1, there are no command-line arguments after the program name.
		-- K & R, 2nd Edition, ch 5, p 115
%
The first optional argument is argv[1] and the last is argv[argc-1]; additionally, the standard requires that argv[argc] be a null pointer.
		-- K & R, 2nd Edition, ch 5, p 115
%
Notice that *++argv is a pointer to an argument string, so (*++argv)[0] is its first character.  (An alternate valid form would be **++argv.)  Because [] binds tighter than * and ++, the parentheses are necessary; without them the expression would be taken as *++(argv[0]).  In fact, that is what we used in the inner loop, where the task is to walk along a specific argument string.  In the inner loop, the expression *++argv[0] increments the pointer argv[0]!
		-- K & R, 2nd Edition, ch 5, p 118
%
In C, a function itself is not a variable, but it is possible to define pointers to functions, which can be assigned, placed in arrays, passed to functions, returned by functions, and so on.
		-- K & R, 2nd Edition, ch 5, p 118
%
A sort often consists of three parts -- a comparison that determines the ordering of any pair of objects, an exchange that reverses their order, and a sorting algorithm that makes comparisons and exchanges until the objects are in order.  The sorting algorithm is independent of the comparison and exchange operations, so by passing different comparison and exchange functions to it, we can arrange to sort by different criteria.
		-- K & R, 2nd Edition, ch 5, p 118-119
%
In the call to `qsort`, `strcmp` and `numcmp` are addresses of functions.  Since they are known to be functions, the & operator is not necessary, in the same way that it is not needed before an array name.
		-- K & R, 2nd Edition, ch 5, p 119
%
Any pointer can be cast to `void *` and back again without loss of information[.]
		-- K & R, 2nd Edition, ch 5, p 120
%
The fourth parameter of qsort is

    int (*comp)(void *, void *)

which says that `comp` is a pointer to a function that has two `void *` arguments and returns an `int`...The parentheses are needed so the components are correctly associated; without them,

    int *comp(void *, void *)       /* WRONG */

says that `comp` is a function returning a poiter to an `int`, which is very different.
		-- K & R, 2nd Edition, ch 5, p 120
%
One good way to synthesize [complicated] declarations is in small steps with `typedef`[.]
		-- K & R, 2nd Edition, ch 5, p 122
%
`dcl` is based on the grammar that specifies a declarator, which is spelled out precisely in Appendix A, Section 8.5; this is a simplified form:

    dcl:            optional *'s direct-dcl
    direct-dcl      name
                    (dcl)
                    direct-dcl()
                    direct-dcl[optional size]

In words, a dcl is a direct-dcl, perhaps preceded by *'s.  A direct-dcl is a name, or a parenthesized dcl, or a direct-dcl followed by parentheses, or a direct-dcl followed by brackets with an optional size.
		-- K & R, 2nd Edition, ch 5, p 122-123
%
A structure is a collection of one or more variables, possibly of different types, grouped together under a single name for convenient handling.  (Structures are called "records" in some languages, notably Pascal.)  Structures help to organize complicated data, particularly in large programs, because they permit a group of related variables to be treated as a unit instead of as separate entities.
		-- K & R, 2nd Edition, ch 6, p 127
%
The main change made by the ANSI standard is to define structure assignment -- structures may be copied and assigned to, passed to functions, and returned by functions.  This has been supported by most compilers for many years, but the properties are now precisely defined.  Automatic structures and arrays may now also be initialized.
		-- K & R, 2nd Edition, ch 6, p 127
%
The keyword `struct` introduces a structure declaration, which is a list of declarations enclosed in braces.  An optional name called a structure tag may follow the word `struct`.  The tag names this kind of structure, and can be used subsequently as a shorthand for the part of the declaration in braces.
		-- K & R, 2nd Edition, ch 6, p 128
%
The variables named in a structure are called members.  A structure member or tag and an ordinary (i.e., non-member) variable can have the same name without conflict, since they can always be distinguished by context.  Furthermore, the same member names may occur in different structures, although as a matter of style one would normally use the same names only for closely related objects.
		-- K & R, 2nd Edition, ch 6, p 128
%
A `struct` declaration defines a type.  The right brace that terminates the list of members may be followed by a list of variables, just as for any basic type.  That is,

    struct { ... } x, y, z;

is syntactically analogous to

    int x, y, z;

in the sense that each statement declares x, y and z to be variables of the named type and causes space to be set aside for them.
		-- K & R, 2nd Edition, ch 6, p 128
%
A structure declaration that is not followed by a list of variables reserves no storage; it merely describes a template or the shape of a structure.  If the declaration is tagged, however, the tag can be used later in definitions of instances of the structure.
		-- K & R, 2nd Edition, ch 6, p 128
%
A structure can be initialized by following its definition with a list of initializers, each a constant expression, for the members:

    struct point maxpt = { 320, 200 };

An automatic structure may also be initialized or by assignment or by calling a function that returns a structure of the right type.
		-- K & R, 2nd Edition, ch 6, p 128
%
The only legal operations on a structure are copying it or assigning to it as a unit, taking its address as &, and accessing its members.  Copy and assignment include passing arguments to functions and returning values from functions as well.  Structures may not be compared.  A structure may be initialized by a list of constant member values; an automatic structure may also be initialized by an assignment.
		-- K & R, 2nd Edition, ch 6, p 129
%
[S]tructure parameters are passed by value like any others.
		-- K & R, 2nd Edition, ch 6, p 130
%
If a large structure is to be passed to a function, it is generally more efficient to pass a pointer than to copy the whole structure.  Structure pointers are just like pointers to ordinary variables.  The declaration

    struct point *pp;

    says that `pp` is a pointer to a structure of type `struct point`.  If `pp` points to a `point` structure, `*pp` is the structure, and `(*pp).x` and `(*pp).y` are the members.  To use `pp`, we might write, for example,

    struct point origin, *pp;
    pp = &origin;
    printf("origin is (%d,%d)\n", (*pp).x, (*pp).y);

The parentheses are necessary in `(*pp).x` because the precedence of the structure operator . is higher than *.  The expression `*pp.x` means `*(pp.x)`, which is illegal here because `x` is not a pointer.
		-- K & R, 2nd Edition, ch 6, p 131
%
Pointers to structures are so frequently used that an alternative notation is provided as a shorthand.  If `p` is a pointer to a structure, then

    p->member-of-structure

refers to the particular member.
		-- K & R, 2nd Edition, ch 6, p 131
%
Both . and -> associate from left to right, so if we have

    struct rect r, *rp = &r;

then these four expressions are equivalent:

    r.pt1.x
    rp->pt1.x
    (r.pt1).x
    (rp->pt1).x
		-- K & R, 2nd Edition, ch 6, p 131
%
The structure operators . and ->, together with () for function calls and [] for subscripts, are at the top of the precedence hierarchy and thus bind very tightly.
		-- K & R, 2nd Edition, ch 6, p 132
%
[G]iven the declaration

    struct {
        int len;
        char *str;
    } *p;

then

    ++p->len

increments `len`, not `p`, because the implied parenthesization is `++(p->len)`.  Parentheses can be used to alter the binding:  `(++p)->len` increments `p` before accessing `len`, and `(p++)->len` increments `p` afterward.  (This last set of parentheses is unnecessary.)
In the same way, `*p->str` fetches whatever `str` points to; `*p->str++` increments `str` after accessing whatever it points to (just like `*s++`); `(*p->str)++` increments whatever `str` points to; and `*p++->str` increments `p` after accessing whatver `str` points to.
		-- K & R, 2nd Edition, ch 6, p 132
%
Since the structure `keytab` contains a constant set of names, it is easiest to make it an external variable and initialize it once and for all when it is defined.  The structure initialization is analagous to earlier ones -- the definition is followed by a list of initializers enclosed in braces:

    struct key {
        char *word;
        int count;
    } keytab[]= {
        "auto", 0,
        "break", 0,
        "case", 0,
        /* ... */
        "void", 0,
        "volatile", 0,
        "while", 0
    };

The initializers are listed in pairs corresponding to the structure members.  It would be more precise to enclose initializers for each "row" or structure in braces, as in

    { "auto", 0 },
    { "break", 0 },
    { "case", 0 },
    ...

but the inner braces are not necessary when the initializers are simple variables or character strings, and when all are present.  As usual, the number of entries in the array `keytab` will be computed if initializers are present and the [] is left empty.
		-- K & R, 2nd Edition, ch 6, p 133
%
A `sizeof` can not be use in a `#if` line, because the preprocessor does not parse type names.  But [an] expression in [a] `#define` is not evaluated by the preprocessor[.]
		-- K & R, 2nd Edition, ch 6, p 135
%
The computation of the middle element can no longer be simply

    mid = (low+high) / 2        /* WRONG */

because the addition of two pointers is illegal.  Subtraction is legal, however, so `high-low` is the number of elements, and thus

    mid = low + (high-low) / 2

sets `mid` to point to the element halfway between `low` and `high`.
		-- K & R, 2nd Edition, ch 6, p 138
%
The most important change is to adjust the algorithm to make sure that it does not generate an illegal pointer or attempt to access an element outside the array.  The problem is that `&tab[-1]` and `&tab[n]` are both outside the limits of the array `tab`.  The former is strictly illegal, and it is illegal to dereference the latter.  The language definition does guarantee, however, that pointer arithmetic that involves the first element beyond the end of an array (that is, `&tab[n]`) will work correctly.
		-- K & R, 2nd Edition, ch 6, p 138
%
Don't assume, however, that the size of a structure is the sum of the sizes of its members.  Because of alignment requirements for different objects, there may be unnamed "holes" in a structure.  Thus, for instance, if a `char` is one bye and an `int` four bytes, the structure

    struct {
        char c;
        int ;
    };

might well require eight bytes, not five.  The `sizeof` operator returns the proper value.
		-- K & R, 2nd Edition, ch 6, p 138
%
[W]hen a function returns a complicated type like a structure pointer, as in

    struct key *binsearch(char *word, struct key *tab, int n)

the function name can be hard to see, and to find with a text editor.  Accordingly an alternate style is sometimes used:

    struct key *
    binsearch(char *word, struct key *tab, int n)

This is a matter of personal taste; pick the form you like and hold to it.
		-- K & R, 2nd Edition, ch 6, p 138
%
It is illegal for a structure to contain an instance of itself[.]
		-- K & R, 2nd Edition, ch 6, p 140
%
Alignment requirements can generally be satisfied easily, at the cost of some wasted space, by ensuring that the allocator always returns a pointer that meets all alignment restrictions.
		-- K & R, 2nd Edition, ch 6, p 142
%
The question of the type declaration for a function like `malloc` is a vexing one for any language that takes its type-checking seriously.  In C, the proper method is to declare that `malloc` returns a pointer to `void`, then explicitly coerce the pointer into the desired type with a cast.  Thus `talloc` can be written as

    #include <stdlib.h>

    /* talloc:  make a tnode */
    struct tnode *talloc(void)
    {
        return (struct tnode *) malloc(sizeof(struct tnode));
    }
		-- K & R, 2nd Edition, ch 6, p 142
%
The `for` loop in `lookup` is the standard idiom for walking along a linked list:

    for (ptr = head; ptr != NULL; ptr = ptr->next)
        ...
		-- K & R, 2nd Edition, ch 6, p 145
%
C provides a facility called `typedef` for creating new data type names.  For example, the declaration

    typedef int Length;

makes the name `Length` a synonym for `int`.  Type `Length` can be used in declarations, casts, etc., in exactly the same ways that the type `int` can be:

    Length  len, maxlen;
    Length  *lengths[];
		-- K & R, 2nd Edition, ch 6, p 145
%
Notice that the type being declared in a `typedef` appears in the position of a variable name, not right after the word `typedef`.  Syntactically, `typedef` is like the storage classes `extern`, `static`, etc.  We have used capitalized names for `typedef`s, to make them stand out.
		-- K & R, 2nd Edition, ch 6, p 146
%
It must be emphasized that a `typedef` declaration does not create a new type in any sense; it merely adds a new name for some existing type.  Nor are there any new semantics; variables declared this way have exactly the same properties as variables whose declarations are spelled out explicitly.  In effect, `typedef` is like `#define`, except that since it is interpreted by the compiler, it can cope with textual substitutions that are beyond the capabilities of the preprocessor.
		-- K & R, 2nd Edition, ch 6, p 146-147
%
Besides purely aesthetic issues, there are two main reasons for using `typedefs`.  The first is to parameterize a program against portability problems.  If `typedef`s are used for data types that may be machine-dependent, only the `typedef`s need change when the program is moved.  One common situation is to use `typedef` names for various integer quantities, then make an appropriate set of choices of `short`, `int`, and `long` for each host machine.  Types like `size_t` and `ptrdiff_t` from the standard library are examples.
The second purpose of `typedef`s is to provide better documentation for a program[.]
		-- K & R, 2nd Edition, ch 6, p 147
%
A union is a variable that may hold (at different times) objects of different types and sizes, with the compiler keeping track of size and alignment requirements.  Unions provide a way to manipulate different kinds of data in a single area of storage without embedding any machine-dependent information in the program.  They are analagous to variant records in Pascal.
		-- K & R, 2nd Edition, ch 6, p 147
%
This is the purpose of a union -- a single variable that can legitimately hold any one of several types.  The syntax is based on structures:

    union u_tag {
        int ival;
        float fval;
        char *sval;
    } u;

The variable `u` will be large enough to hold the largest of the three types; the specific size is implementation-dependent.
		-- K & R, 2nd Edition, ch 6, p 147
%
Syntactically, members of a union are accessed as

    union-name.member

or

    union-pointer->member

just as for structures.
		-- K & R, 2nd Edition, ch 6, p 148
%
In effect, a union is a structure in which all members have offset zero from the base, the structure is big enough to hold the "widest" member, and the alignment is appropriate for all of the types in the union.  The same operations are permitted on unions as on structures: assignment to or copying as a unit, taking the address, and accessing a member.
		-- K & R, 2nd Edition, ch 6, p 148
%
A union may only be initialized with a value of the type of its first member[.]
		-- K & R, 2nd Edition, ch 6, p 148
%
When storage space is at a premium, it may be necessary to pack several objects into a single machine word; one common use is a set of single-bit flags in applications like compiler symbol tables.
		-- K & R, 2nd Edition, ch 6, p 149
%
Certain idioms appear frequently:

    flags |= EXTERNAL | STATIC;

turns on the EXTERNAL and STATIC bits in `flags`, while

    flags &= ~(EXTERNAL | STATIC);

turns them off, and

    if ((flags & (EXTERNAL | STATIC)) == 0) ...

is true if both bits are off.
		-- K & R, 2nd Edition, ch 6, p 149
%
C offers the capability of defining and accessing fields within a word directly rather than by bitwise logical operators.  A bit-field, or field for short, is a set of adjacent bits within a single implementation-defined storage unit that we will call a "word."  The syntax of field definition and access is based on structures.
		-- K & R, 2nd Edition, ch 6, p 149
%
For example, the [following] symbol table

    #define KEYWORD 01
    #define EXTERNAL 02
    #define STATIC 04

could be replaced by the definition of three fields:

    struct {
        unsigned int is_keyword : 1;
        unsigned int is_extern  : 1;
        unsigned int is_static  : 1;
    } flags;

This defines a variable called `flags` that contains three 1-bit fields.  The number following the colon represents the field width in bits.  The fields are declared `unsigned int` to ensure that they are unsigned quantities.
		-- K & R, 2nd Edition, ch 6, p 149-150
%
Individual [bit-]fields are referenced in the same way as other structure members: `flags.is_keyword`, `flags.is_extern`, etc.  Fields behave like small integers, and may participate in arithmetic expressions just like other integers.
[Compare the bitwise expressions and the field expressions]

    flags |= EXTERNAL | STATIC;
    vs
    flags.is_extern = flags.is_static = 1;

turns on the EXTERNAL and STATIC bits in `flags`, while

    flags &= ~(EXTERNAL | STATIC);
    vs
    flags.is_extern = flags.is_static = 0;

turns them off, and

    if ((flags & (EXTERNAL | STATIC)) == 0) ...
    vs
    if (flags.is_extern == 0 && flags.is_static == 0) ...

is true if both bits are off.
		-- K & R, 2nd Edition, ch 6, p 150
%
Almost everything about [bit-]fields is implementation-dependent.  Whether a field may overlap a word boundary is implementation-defined.  Fields may not be named; unnamed fields (a colon and width only) are used for padding.  The special width 0 may be used to force alignment at the next word boundary.
		--K & R, 2nd Edition, ch 6, p 150
%
Fields are assigned left to right on some machines and right to left on others.  This means that although fields are useful for maintaining internally-defined data structures, the question of which end comes first has to be carefully considered when picking apart externally-defined data; programs that depend on such things are not portable.  Fields may be declared only as `int`s; for portability, specify `signed` or `unsigned` explicitly.  They are not arrays, and they do not have addresses, so the & operator cannot be applied to them.
		--K & R, 2nd Edition, ch 6, p 150
%
The ANSI standard defines these [input and output] library functions precisely, so that they can exist in compatible form on any system where C exists.  Programs that confine their systems interactions to facilities provided by the standard library can be moved from one system to another without change.
		--K & R, 2nd Edition, ch 7, p 151
%
[T]he library implements a simple model of text input and output.  A text stream consists of a sequence of lines; each line ends with a newline character.  If the system doesn't operate that way, the library does whatever is necessary to make it appear as if it does.  For instance, the library might convert carriage return and line feed to newline on input and back again on output.
		--K & R, 2nd Edition, ch 7, p 151
%
The symbolic constant EOF is defined in <stdio.h>.  The value is typically -1, but tests should be written in terms of EOF so as to be independent of the specific value.
		--K & R, 2nd Edition, ch 7, p 151-152
%
[When redirecting standard input], the string "<infile" is not included in the command-line arguments in `argv`.
		--K & R, 2nd Edition, ch 7, p 152
%
"[F]unctions" like `getchar` and `putchar` in <stdio.h> and `tolower` in <ctype.h> are often macros, thus avoiding the overhead of a function call per character.
		--K & R, 2nd Edition, ch 7, p 153
%
The format string [of `printf`] contains two types of objects: ordinary characters, which are copied to the output stream, and conversion specifications, each of which causes conversion and printing of the next successive argument to `printf`.  Each conversion specification begins with a % and ends with a conversion character.  Between the % and the conversion character there may be, in order:

    - A minus sign, which specifies left adjustment of the converted argument.
    - A number that specifies the minimum field width.  The converted argument will be printed in a field at least this wide.
      If necessary it will be padded on the left (or right, if left adjustment is called for) to make up the field width.
    - A period, which separates the field width from the precision.
    - A number, the precision, that specifies the maximum number of characters to be printed from a string, or the number of
      digits after the decimal point of a floating-point value, or the minimum number of digits for an integer.
    - An `h` if the integer is to be printed as a `short`, or `l` (letter ell) if as a `long`.
If the character after the % is not a conversion specification, the behavior is undefined.
		--K & R, 2nd Edition, ch 7, p 153-154
%
A width or precision [for `printf`] may be specified as *, in which case the value is computed by converting the next argument (which must be an `int`).  For example, to print at most `max` characters from a string `s`,

    printf("%.*", max, s);
		--K & R, 2nd Edition, ch 7, p 154
%
`printf` uses its first argument to decide how many arguments follow and what their types are.  It will get confused, and you will get wrong answers, if there are not enough arguments or if they are the wrong type.
		--K & R, 2nd Edition, ch 7, p 154-155
%
[T]he declaration `...` means that the number and types of these arguments may vary.  The declaration `...` can only appear at the end of an argument list.
		--K & R, 2nd Edition, ch 7, p 155
%
The standard header <stdarg.h> contains a set of macro definitions that define how to step through an argument list.  The implementation of this header will vary from machine to machine, but the interface it presents is uniform.
		--K & R, 2nd Edition, ch 7, p 155
%
The function `scanf` is the input analog of `printf`, providing many of the same conversion facilities in the opposite direction.
		--K & R, 2nd Edition, ch 7, p 157
%
The [`scanf`] format string usually contains conversion specifications, which are used to control conversion of input.  The format string may contain:

    - Blanks or tabs, which are ignored.
    - Ordinary characters (not %), which are expected to match the next non-white space character of the input stream.
    - Conversion specifications, consisting of the character %, an optional assignment suppression character *, an
      optional number specifying a maximum field width, an optional `h`, `l`, or `L` indicating the width of the target,
      and a conversion character.
		--K & R, 2nd Edition, ch 7, p 157
%
The conversion character [of `scanf`] indicates the interpretation of the input field.  The corresponding argument must be a pointer, as required by the call-by-value semantics of C.
		--K & R, 2nd Edition, ch 7, p 157-158
%
Suppose we want to read input lines that contain dates of the form

    25 Dec 1988

The `scanf` statement is

    int day, year;
    char monthname[20];

    scanf("%d %s %d", &day, monthname, &year);

No & is used with `monthname`, since an array name is a pointer.
		--K & R, 2nd Edition, ch 7, p 158-159
%
Literal characters can appear in the `scanf` format string; they must match the same characters in the input.  So we could read dates of the form mm/dd/yy with this `scanf` statement:

    int day, month, year;

    scanf("%d/%d/%d", &month, &day, &year);
		--K & R, 2nd Edition, ch 7, p 159
%
To read input whose format is not fixed, it is often best to read a line at a time, then pick it apart with `sscanf`.
		--K & R, 2nd Edition, ch 7, p 159
%
Calls to `scanf` can be mixed with calls to other input functions.  The next call to any input function will begin by reading the first character not read by `scanf`.
		--K & R, 2nd Edition, ch 7, p 159
%
[T]he arguments to `scanf` and `sscanf` must be pointers.  By far the most common error is writing

    scanf("%d", n);

instead of

    scanf("%d", &n);

The error is generally not detected at compile time.
		--K & R, 2nd Edition, ch 7, p 159
%
Before it can be read or written, a file has to be opened by the library function `fopen`.  `fopen` takes an external name like `x.c` or `y.c`, does some housekeeping and negotiation with the operating system (details of which needn't concern us), and returns a pointer to be used in subsequent reads or writes of the file.
		--K & R, 2nd Edition, ch 7, p 160
%
This pointer, called the file pointer, points to a structure that contains information about the file, such as the location of a buffer, the current character position in the buffer, whether the file is being read or written, and whether errors or end of file has occurred.  Users don't need to know the details, because the definitions obtained from <stdio.h> include a structure declaration called `FILE`.
		--K & R, 2nd Edition, ch 7, p 160
%
If a file that does not exist is opened for writing or appending, it is created if possible.  Opening an existing file for writing causes the old contents to be discarded, while opening for appending preserves them.  Trying to read a file that does not exist is an error, and there may be other causes of error as well, like to read a file when you don't have permission.  If there is any error, `fopen` will return `NULL`.
		--K & R, 2nd Edition, ch 7, p 161
%
Like `getchar` and `putchar`, `getc` and `putc` may be macros instead of functions.
		--K & R, 2nd Edition, ch 7, p 161
%
When a C program is started, the operating system environment is responsible for opening three files and providing file pointers for them.  These files are the standard input, the standard output, and the standard error; the corresponding file pointers are called `stdin`, `stdout`, and `stderr`, and are declared in <stdio.h>.  Normally `stdin` is connected to the keyboard and `stdout` and `stderr` are connected to the screen, but `stdin` and `stdout` may be redirected to files or pipes[.]
		--K & R, 2nd Edition, ch 7, p 161
%
`getchar` and `putchar` can be defined in terms of `getc`, `putc`, `stdin`, and `stdout` as follows:

    #define getchar()   getc(stdin)
    #define putchar(c)  putc((c), stdout)
		--K & R, 2nd Edition, ch 7, p 161
%
For formatted input or output of files, the functions `fscanf` and `fprintf` may be used.  These are identical to `scanf` and `printf`, except that the first argument is a file pointer that specifies the file to be read or written; the format string is the second argument.
		--K & R, 2nd Edition, ch 7, p 161
%
The file pointers `stdin` and `stdout` [and `stderr`] are objects of type `FILE *`.  They are constants, however, not variables, so it is not possible to assign them.
		--K & R, 2nd Edition, ch 7, p 162
%
The function

    int fclose(FILE *fp)

is the inverse of `fopen`; it breaks the connection between the file pointer and the external name that was established by `fopen`, freeing the file pointer for another file.  Since most operating systems have some limit on the number of files that a program may have open simultaneously, it's a good idea to free file pointers when they are no longer needed[.]  There is also another reason for `fclose` on an output file -- it flushes the buffer in which `putc` is collecting output.  `fclose` is called automatically for each open file when a program terminates normally.  (You can close `stdin` and `stdout` if they are not needed.  They can also be reassigned by the library function `freopen`.)
		--K & R, 2nd Edition, ch 7, p 162
%
Output written on `stderr` normally appears on the screen even if the standard output is redirected.
		--K & R, 2nd Edition, ch 7, p 163
%
The program signals errors two ways.  First, the diagnostic output produced by `fprintf` goes onto `stderr`, so it finds its way to the screen instead of disappearing down a pipeline or into an input file.  We included the program name, from `argv[0]`, in the message, so if this program is used with others, the source of an error is identified.
Second, the program uses the standard library function `exit`, which terminates program execution when it is called.  The argument of `exit` is available to whatever process called this one, so the success or failure of the program can be tested by another program that uses this one as a sub-process.  Conventionally, a return value of 0 signals that all is well; non-zero values usually signal abnormal situations.  `exit` calls `fclose` for each open output file, to flush out any buffered output.
		--K & R, 2nd Edition, ch 7, p 163
%
The function `ferror` returns non-zero if an error occurred on the stream `fp`.

    int ferror(FILE *fp)

Although output errors are rare, they do occur (for example, if a disk fills up), so a production program should check this as well.
		--K & R, 2nd Edition, ch 7, p 164
%
The function `feof(FILE *)` is analogous to `ferror`; it returns non-zero if end of file has occurred on the specified file.

    int feof(FILE *fp)
		--K & R, 2nd Edition, ch 7, p 164
%
[A]ny serious program should take care to return sensible, useful status values.
		--K & R, 2nd Edition, ch 7, p 164
%
    char *fgets(char *line, int maxline, FILE *fp)

`fgets` reads the next input line (including the newline) from file `fp` into the character array `line`; at most `maxline`-1 characters will be read.  The resulting line is terminated with a '\0'.  Normally `fgets` returns `line`; on end of file or error it returns NULL.
		--K & R, 2nd Edition, ch 7, p 164
%
The standard specifies that `ferror` returns non-zero for error; `fputs` returns EOF for error and a non-negative value otherwise.
		--K & R, 2nd Edition, ch 7, p 165
%
The pointer returned by `malloc` or `calloc` has the proper alignment for the object in question, but it must be cast to the appropriate type, as in

    int *ip;

    ip = (int *) calloc(n, sizeof(int));
		--K & R, 2nd Edition, ch 7, p 167
%
`free(p)` frees the space pointed to by `p`, where `p` was originally obtained by a call to `malloc` or `calloc`.  There are no restrictions on the order in which space is freed, but it is a ghastly error to free something not obtained by calling `calloc` or `malloc`.
It is also an error to use something after it has been freed.
		--K & R, 2nd Edition, ch 7, p 167
%
The function `rand()` computes a sequence of pseudo-random integers in the range zero to RAND_MAX, which is defined in <stdlib.h>.  One way to produce random floating-point numbers greater than or equal to zero but less than one is

    #define frand() ((double) rand() / (RAND_MAX+1.0))

(If your library already provides a function for floating-point random numbers, it is likely to have better statistical properties than this one.)
		--K & R, 2nd Edition, ch 7, p 168
%
The UNIX operating system provides its services through a set of system calls, which are in effect functions within the operating system that may be called by user programs.
		--K & R, 2nd Edition, ch 8, p 169
%
On any particular system the routines of the standard library have to be written in terms of the facilities provided by the host system.
		--K & R, 2nd Edition, ch 8, p 169
%
In the UNIX operating system, all input and output is done by reading or writing files, because all peripheral devices, even keyboard and screen, are files in the file system.  This means that a single homogeneous interface handles all communication between a program and peripheral devices.
		--K & R, 2nd Edition, ch 8, p 169
%
Whenever input or output is to be done on the file, the file descriptor [a small non-negative integer returned by the system when a file is opened] is used instead of the name to identify the file.  (A file descriptor is analogous to the file pointer used by the standard library, or to the file handle of MS-DOS.)  .All information about an open file is maintained by the system; the user program refers to the file only by the file descriptor.
		--K & R, 2nd Edition, ch 8, p 170
%
Since input and output involving keyboard and screen is so common, special arrangements exist to make this convenient.  When the command interpreter (the "shell") runs a program, three files are open, with file descriptors 0, 1, and 2, called the standard input, the standard output, and the standard error.  If a program reads 0 and writes 1 and 2, it can do input and output without worrying about opening files.
		--K & R, 2nd Edition, ch 8, p 170
%
The user of a program can redirect I/O to and from files with < and >:

    prog <infile >outfile

In this case, the shell changes the default assignments for file descriptors 0 and 1 to the named files.  Normally file descriptor 2 remains attached to the screen, so error messages can go there.  Similar observations hold for input or output associated with a pipe.  In all cases, the file assignments are changed by the shell, not by the program.  The program does not know where its input comes from nor where its output goes, so long as it uses file 0 for input and 1 and 2 for output.
		--K & R, 2nd Edition, ch 8, p 170
%
Input and output uses the `read` and `write` system calls, which are accessed from C programs through two functions called `read` and `write`.  For both, the first argument is a file descriptor.
		--K & R, 2nd Edition, ch 8, p 170
%
Any number of bytes can be read or written in one call.  The most common values are 1, which means one character at at time ("unbuffered"), and a number like 1024 or 4096 that corresponds to a physical block size on a peripheral device.  Larger sizes will be more efficient because fewer system calls will be made.
		--K & R, 2nd Edition, ch 8, p 170-171
%
The standard library function `vprintf` is like `printf` except that the variable argument list is replaced by a single argument that has been initialized by calling the `va_start` macro.  Similarly, `vprintf` and `vsprintf` match `fprintf and `sprintf`.
		--K & R, 2nd Edition, ch 8, p 174
%
There is a limit (often about 20) on the number of files that a program may have open simultaneously.  Accordingly, any program that intends to process many files must be prepared to re-use file descriptors.  The function `close(int fd)` breaks the connection between a file descriptor and an open file, and frees the file descriptor for use with some other file; it corresponds to `fclose` in the standard library except that there is no buffer to flush.  Termination of a program via `exit` or return from the main program closes all open files.
		--K & R, 2nd Edition, ch 8, p 174
%
The function `unlink(char *name)` removes the file name from the file system.  It corresponds to the standard library function `remove`.
		--K & R, 2nd Edition, ch 8, p 174
%
