The model of input and output supported by the standard library is very simple.  Text input or output, regardless of where it originates or where it goes to, is dealt with as streams of characters.  A text stream is a sequence of characters divided into lines; each line consists of zero or more characters followed by a newline character.  It is the responsibility of the library to make each input or output stream conform to this model; the C programmer using the library need not worry about how lines are represented outside of the program.
        -- K & R, 2nd, Edition, ch 1, p 15
%
The body of this for loop is empty, because all of the work is done in the test and increment parts.  But the grammatical rules of C require that a for statement have a body.  The isolated semicolon, called a `null statement`, is there to satisfy that requirement.  We put it on a separate line to make it visible.
		-- K & R, 2nd Edition, ch 1, p 19
%
A character written between single quotes represents an integer value equal to the numerical value of the character in the machine's character set.  This is called a `character constant`, although it is just another way to write a small integer.
		-- K & R, 2nd Edition, ch 1, p 19
%
By definition, chars are just small integers, so char variables and constants are identical to ints in arithmetic expressions.
        -- K & R, 2nd Edition, ch 1, p 23
%
We will generally use `parameter` for a variable named in the parenthesized list in a function definition, and `argument` for the value used in a call of the function.  The terms `formal argument` and `actual argument` are sometimes used for the same distinction.
		-- K & R, 2nd Edition, ch 1, p 25
%
[P]rograms should return status to their environment.
		-- K & R, 2nd Edition, ch 1, p 26
%
Well-chosen names are good documentation.
		-- K & R, 2nd Edition, ch 1, p 26
%
In C, all function arguments are passed "by value."  This means that the called function is given the values of its arguments in temporary variables rather than the originals...[T]he called function cannot directly alter a variable in the calling function; it can only alter its private, temporary copy.
		-- K & R, 2nd Edition, ch 1, p 27
%
When the name of an array is used as an argument, the value passed to the function is the location or address of the beginning of the array -- there is no copying of array elements.  By subscripting this value, the function can access and alter any element of the array.
		-- K & R, 2nd Edition, ch 1, p 28
%
The purpose of supplying the size of an array in a declaration is to set aside storage.
		-- K & R, 2nd Edition, ch 1, p 30
%
Each local variable in a function comes into existence only when the function is called, and disappears when the function is exited.  This is why such variables are known as `automatic` variables, following terminology in other languages.  We will use the term automatic henceforth to refer to these local variables.
		-- K & R, 2nd Edition, ch 1, p 31
%
[C]ommon practice is to place definitions of all external variables at the beginning of the source file, and then omit all `extern` declarations.
		-- K & R, 2nd Edition, ch 1, p 33
%
If the program is in several source files, and a variable is defined in `file1` and used in `file2` and `file3`, then `extern` declarations are needed in `file2` and `fil` to connect the occurrences of the variable.  The usual practice is to collect `extern` declarations of variables and functions is a separate file, historically called a `header`, that is included by `#include` at the beginning of each source file.  The suffix `.h` is conventional for header names.
		-- K & R, 2nd Edition, ch 1, p 33
%
Relying too heavily on external variables is fraught with peril since it leads to programs whose data connections are not at all obvious -- variables can be changed in unexpected and even inadvertent ways, and the program is hard to modify.
		-- K & R, 2nd Edition, ch 1, p 34
%
The type of an object determines the set of values it can have and what operations can be performed on it.
		-- K & R, 2nd Edition, ch 2, p 35
%
Names are made up of letters and digits; the first character must be a letter...[d]on't begin variables names with underscore, however, since library routines often use such names...[t]raditional C practice is to use lower case for variable names, and all upper case for symbolic constants.
		-- K & R, 2nd Edition, ch 2, p 35
%
At least the first 31 characters of an internal name are significant.  For function names and external variables, the number may be less than 31, because external names may be used by assemblers and loaders over which the language has no control.  For external names, the standard guarantees uniqueness only for 6 characters and a single case.
		-- K & R, 2nd Edition, ch 2, p 35
%
There are only a few basic data types in C:

	char	a single byte, capable of holding one character
		in the local character set.
	int	an integer, typically reflecting the natural size
		of integers on the host machine.
	float	single-precision floating point.
	double	double-precision floating point.

In addition, there are a number of qualifiers that can be applied to these basic types.  `short` and `long` apply to integers:

	short int sh;
	long int counter;

The word `int` can be omitted in such declarations, and typically is.
	-- K & R, 2nd Edition, ch 2, p 36
%
Each compiler is free to choose appropriate sizes [of integers] for its own hardware, subject only to the restriction that `short`s and `int`s are at least 16 bits, `long`s are at least 32 bits, and `short` is no longer than `int`, which is no longer than `long`.
		-- K & R, 2nd Edition, ch 2, p 35
%
The qualifer `signed` or `unsigned` may be applied to `char` or any integer.  `unsigned` numbers are always positive or zero, and obey the laws of arithmetic modulo 2^n, where `n` is the number of bits in the type.  So, for instance, if `chars` are 8 bits, `unsigned char` variables have values between 0 and 255, while `signed chars` have values between -128 and 127 (int a two's-complement machine).  Whether plain `chars` are signed or unsigned is machine-dependent, but printable characters are always positive.
		-- K & R, 2nd Edition, ch 2, p 36
%
An integer constant like 1234 is an `int`.  A long constant is written with a terminal `l` (ell) or `L`, as in 123456789L; an integer too big to fit into an `int` will also be taken as a `long`.  Unsigned constants are written with a terminal `u` or `U`, and the suffix `ul` or `UL` indicates `signed long`.
		-- K & R, 2nd Edition, ch 2, p 37
%
Floating-point constants contain a decimal point (123.4) or an exponent (1e-2) or both; their type is `double`, unless suffixed.  The suffixes `f` or `F` indicate a `float` constant; `l` or `L` indicate a `long double`.
		-- K & R, 2nd Edition, ch2, p 37
%
The value of an integer can be specified in octal or hexadecimal instead of decimal.  A leading zero (0) on an integer constant means octal; a leading 0x or 0X means hexadecimal...Octal and hexadecimal constants may also be followed by `L` to make them `long` and `U` to make them unsigned (ed. note -- i.e., 0XFUL).
		-- K & R, 2nd Edition, ch 2, p 37
%
A character constant is an integer, written as one character within single quotes, such as 'x'.  The value of a character constant is the numeric value of the character in the machine's character set.  For example, in the ASCII character set the character constant '0' has the value 48, which is unrelated to the numeric value 0.
		-- K & R, 2nd Edition, ch 2, p 37
%
Certain characters can be represented in character and string constants by escape sequences like \n (newline); these sequences look like two characters, but represent only one.  In addition, an arbitrary byte-sized bit pattern can be specified by

	'\ooo'

where `ooo` is one to three octal digits (0...7) or by

	'\xhh'

where `hh` is one or more hexadecimal digits (0...9, a...f, A...F).  So we might write

	#define VTAB '\013'	/* ASCII vertical tab */
	#define BELL '\007'	/* ASCII bell character */

or, in hexadecimal,

	#define VTAB '\xb'	/* ASCII vertical tab */
	#define BELL '\x7'	/* ASCII bell character */
		-- K & R, 2nd Edition, ch 2, p 37-38
%
The character constant '\0' represents the character with value zero, the null character.  '\0' is often written instead of 0 to emphasize the character nature of some expressio but the numeric value is just 0.
		-- K & R, 2nd Editionk, ch 2, p 38
%
String constants can be concatenated at compile time:

	"hello," " world"

is equivalent to

	"hello, world"

This is useful for splitting long strings across several source lines.
		-- K & R, 2nd Edition, ch 2, p 38
%
Technically, a string constant is an array of characters.  The internal representation of a string has a null character '\0' at the end, so the physical storage required is one more than the number of characters written between the quotes.  This representation means that there is no limit to how long a string can be[.]
		-- K & R, 2nd Edition, ch 2, p 38
%
There is one other kind of constant, the enumeration constant.  An enumeration is a list of constant integer values, as in

	enum boolean { NO, YES };

The first name in an `enum` has value 0, the next 1, and so on, unless explicit values are specified.  If not all values are specified, unspecified values continue the progression from the last specified value...Names in different enumerations must be distinct.  Values need not be distinct in the same enumeration.
		-- K & R, 2nd Edition, ch 2, p 39
%
Enumerations provide a convenient way to associate constant values with names, an alternative to `#define` with the advantage that the values can be generated for you.  Although variables of `enum` types may be declared, compilers need not check that what you store in such a variable is a valid value for the enumeration.  Nevertheless, enumeration variables offer the chance of checking and so are often better then `#define`s.  In addition, a debugger may be able to print values of enumeration variables in their symbolic form.
		-- K & R, 2nd Edition, ch 2, p 39
%
External and static variables are initialized to zero by default.  Automatic variables for which there is no explicit initializer have undefined (i.e., garbage) values.
		-- K & R, 2nd Edition, ch 2, p 40
%
The qualifier `const` can be applied to the declaration of any variable to specify that its value will not be changed.  For an array, the `const` qualifier says that the elements will not be altered...The `const` declaration can also be used with array arguments, to indicate that the function does not change the array:

    int strlen(const char[]);
		-- K & R, 2nd Edition, ch 2, p 40
%
The binary + and - operators have the same precedence, which is lower than the precedence of *, /, and %, which is in turn lower than unary + and -.  Arithmetic operators associate left to right.
		-- K & R, 2nd Edition, ch 2, p 41
%
The relational operators are

	>	>=	<	<=

They all have the same precedence.  Just below them in precedence are the equality operators:

	==	!=

Relational operators have lower precedence than arithmetic operators, so an expression like `i < lim-1` is taken as `i < (lim-1)`, as would be expected.
		-- K & R, 2nd Edition, ch 2, p 41
%
The precedence of && is higher than ||, and both are lower than relational and equality operators, so expressions like

	i<lim-1 && (c = getchar()) != '\n' && c != EOF

need no extra parentheses.
		-- K & R, 2nd Edition, ch 2, p 42
%
By definition, the numeric value of a relational or logical expression is 1 if the relation is true, and 0 if the relation is false.
		-- K & R, 2nd Edition, ch 2, p 42
%
The unary negation operator ! converts a non-zero operand into 0, and a zero operand into a 1.
		-- K & R, 2nd Edition, ch 2, p 42
%
When an operator has operands of different types, they are converted to a common type according to a small number of rules.  In general, the only automatic conversions are those that convert a "narrower" operand into a "wider" one without losing information, such as converting an interger to a floating point in an expression like `f + i`.  Expressions that don't make sense, like using a `float` as a subscript, are disallowed.  Expressions that might lose information, like assigning a longer integer type to a shorter, or a floating-point type to an integer, may draw a warning, but they are not illegal.
		-- K & R, 2nd Edition, ch 2, p 42
%
There is one subtle point about the conversion of characters to integers.  The language does not specify whether variables of type `char` are signed or unsigned quantities.  When `char` is converted to an `int`, can it ever produce a negative number?  The answer varies from machine to machine, reflecting differences in architecture.  On some machines a `char` whose leftmost bit is 1 will be converted to a negative integer ("sign extension").  On others, a `char` is promoted to an `int` by adding zeros at the left end, and thus is always positive.
		-- K & R, 2nd Edition, ch 2, p 43-44
%
The definition of C guarantees that any character in the machine's standard printing character set will never be negative, so these characters will always be positive quantities in expressions.  But arbitrary bit patterns stored in character variables may appear to be negative on some machines, yet positive on others.  For portability, specify `signed` or `unsigned` if non-character data is to be stored in `char` variables.
		-- K & R, 2nd Edition, ch 2, p 44
%
Implicit arithmetic conversions work much as expected.  In general, if an operator like + or * that takes two operands (a binary operator) has operands of different types, the "lower" type is promoted to the "higher" type before the operation proceeds.  The result is of the higher type.
		-- K & R, 2nd Edition, ch 2, p 44
%
Since an argument of a function call is an expression, type conversions also take place when arguments are passed to functions.  In the absence of a function prototype, `char` and `short` become `int`, and `float` becomes `double`.
		-- K & R, 2nd Edition, ch 2, p 45
%
[E]xplicit type conversions can be forced ("coerced") in any expression, with a unary operator called a cast.  In the construction

	(type-name) expression

the expression is converted to the named type by the conversion rules[.]
		-- K & R, 2nd Edition, ch 2, p 45
%
The cast operator has the same high precedence as other unary operators[.]
		-- K & R, 2nd Edition, ch 2, p 45
%
If arguments are declared by a function prototype, as they normally should be, the declaration causes automatic coercion of any arguments when the function is called.  Thus, given a function prototype for `sqrt`:

	double sqrt(double);

the call

	root2 = sqrt(2);

coerces the integer 2 into the double value 2.0 without any need for a cast.
		-- K & R, 2nd Edition, ch 2, p 45
%
C provides six operators for bit manipulation; these may only be applied to integral operands, that is, `char`, `short`, `int`, and `long`, whether signed or unsigned.
		-- K & R, 2nd Edition, ch 2, p 48
%
The bitwise AND operator & is often used to mask off some set of bits; for example,

	n = n & 0177;

sets to zero all but the low-order 7 bits of n.
The bitwise OR operator | is used to turn bits on:

	x = x | SET_ON;

sets to one in x the bits that are set to one in SET_ON.
		-- K & R, 2nd Edition, ch 2, p 48
%
Right shifting an `unsigned` quantity always fills vacated bits with zero.  Right shifting a signed quantity will fill with sign bits ("arithmetic shift") on some machines and with 0-bits ("logical shifts") on others.
		-- K & R, 2nd Edition, ch 2, p 49
%
The operator += is called an 'assignment operator.'
		-- K & R, 2nd Edition, ch 2, p 50
%
	x *= y + 1

means

	x = x * (y + 1)

rather than

	x = x * y + 1
		-- K & R, 2nd Edition, ch 2, p 50
%
Declaring the argument `x` to be `unsigned` ensures that when it is right-shifted, vacated bits will be filled with zeros, not sign bits, regardless of the machine the program is run on.
		-- K & R, 2nd Edition, ch 2, p 50
%
[T]he expression `i += 2` is preferable to `i = i + 2`.
		-- K & R, 2nd Edition, ch 2, p 51
%
[A]n assignment operator may even help a compiler to produce efficient code.
		-- K & R, 2nd Edition, ch 2, p 51
%
[T]the type of an assignment expression is the type of its left operand, and the value is the value after assignment.
		-- K & R, 2nd Edition, ch 2, p 51
%
The conditional expression, written with the ternary operator "?:", provides an alternate way to write [an if/else block] and similar constructions.
		-- K & R, 2nd Edition, ch 2, p 51
%
Parentheses are not necessary around the first expression of a conditional expression, since the precedence of ?: is very low, just above assignment.  They are advisable anyway, however, since they make the condition part of the expression easier to see.
		-- K & R, 2nd Edition, ch 2, p 52
%
C, like most languages, does not specify the order in which the operands of an operator are evaluated. (The exceptions are &&, ||, ?:, and ','.)
		-- K & R, 2nd Edition ch 2, p 52
%
[T]he order in which function arguments are evaluated is not specified, so the statement

	printf("%d %d\n", ++n, power(2, n));	/* WRONG */

can produce different results with different compilers, depending on whether `n` is incremented before `power` is called.  The solution, of course, is to write

	++n;
	printf("%d %d\n", n, power(2, n));
		-- K & R, 2nd Edition, ch 2, p 53
%
Function calls, nested assignment statements, and increment and decrement operators cause "side effects" -- some variable is changed as a by-product of the evaluation of an expression.  In any expression involving side effects, there can be subtle dependencies on the order in which variables taking part in the expression are updated.
		-- K & R, 2nd Edition, ch 2, p 53
%
Compilers can interpret [the order in which expressions are evaluated] in different ways, and generate different answers depending on their interpretation.  The standard intentionally leaves most such matters unspecified.  When side effects (aignment to variables) take place within an expression is left to the discretion of the compiler, since the best order depends strongly on machine architecture.
		-- K & R, 2nd Edition, ch 2, p 54
%
The moral is that writing code that depends on order of evaluation is a bad programming practice in any language.  Naturally, it is necessary to know what things to avoid, but if you don't know how they are done on various machines, you won't be tempted to take advantage of a particular implementation.
		-- K & R, 2nd Edition, ch 2, p 54
%
In C, the semicolon is a statement terminator, rather than a separator as it is in languages like Pascal.
		-- K & R, 2nd Edition, ch 3, p 55
%
Braces { and } are used to group declarations and statements together into a compound statement, or block, so that they are syntactically equivalent to a single statement.
		-- K & R, 2nd Edition, ch 3, p 55
%
[I]t's a good idea to use braces when there are nested `if`s.
		-- K & R, 2nd Edition, ch 3, p 56
%
`break` and `return` are the most common ways to leave a `switch`.  A `break` statement can also be used to force and immediate exit from `while`, `for`, and `do` loops[.]
		-- K & R, 2nd Edition, ch 3, p 59
%
As a matter of good form, put a `break` after the last case [in a `switch`] even though it's logically unnecessary.  Some day when another case gets added at the end, this bit of defensive programming will save you.
		-- K & R, 2nd Edition, ch3, p 59
%
The `for` statement

	for (expr1; expr2; expr3)
		statement

is equivalent to

	expr1;
	while (expr2) {
        statement
        expr3;
	}

except for the behavior of `continue`[.]
		-- K & R, 2nd Edition, ch 3, p 60
%
Grammatically, the three components of a `for` loop are expressions.  Most commonly, expr1 and expr3 are assignments or function calls and expr2 is a relational expression.  Any of the three parts [of a `for` loop] can be omitted, although the semi-colons must remain.  If expr1 or expr3 is omitted, it is simply dropped from the expansion.  If the test, expr2, is not present, it is taken as permanently true, so

	for (;;) {
        ...
	}

is an "infinite" loop, presumably to be broken by other means, such as a `break` or `return`.
		-- K & R, 2nd Edition, ch 3, p 60
%
Whether to use `while` or `for` is largely a matter of personal preference...The `for` is preferable when there is a simple initialization and increment, since it keeps the loop control statments close together and visible at the top of the loop.
		-- K & R, 2nd Edition, ch 3, p 60-61
%
Because the components for the `for` are arbitrary expressions, `for` loops are not restricted to arithmetic progressions.  Nonetheless, it is bad style to force unrelated computation into the initialization and increment of a `for`, which are better reserved for loop control operations.
		K & R, 2nd Edition, ch 3, p 61
%
One final C operator is the comma ",", which most often finds use in the `for` statement.  A pair of expressions separated by a comma is evaluated left to right, and the type and value of the result are the type and value of the right operand.
		-- K & R, 2nd Edition, ch 3, p 62
%
The commas that separate function arguments, variables in declarations, etc., are not comma operators, and do not guarantee left to right evaluation.
		-- K & R, 2nd Edition, ch 3, p 63
%
Comma operators should be used sparingly.  The most suitable uses are for constructs strongly related to each other, as in the `for` loop, and in macros where a multistep computation has to be a single expression.
		-- K & R, 2nd Edition, ch 3, p 63
%
[T]he third loop in C, the `do-while`, tests at the bottom after making each pass through the loop body; the body is always executed at least once.  The syntax of the `do` is

    do
        statement
    while (expression);
		-- K & R, 2nd Edition, ch 3, p 63
%
The `break` statement provides an early exit from `for`, `while`, and `do`, just as from `switch`.  A `break` causes the innermost enclosing loop or `switch` to be exited immediately.
		-- K & R, 2nd Edition, ch 3, p 64
%
The `continue` statement is related to `break`, but less often used; it causes the next iteration of the enclosing `for`, `while`, or `do` loop to begin.  In the `while` and `do`, this means that the test part is executed immediately; in the `for`, control passes to the increment step.  The `continue` statement applies only to loops, not to `switch`.  A `continue` inside a `switch` inside a loop causes the next loop iteration.
		-- K & R, 2nd Edition, ch 3, p 65
%
C provides the infinitely-abusable `goto` statement, and labels to branch to.  Formally, the `goto` is never necessary, and in practice it is almost always easy to write code without it.  We have not used `goto` in this book.
Nevertheless, there are a few situations where `goto`s may find a place.  The most common is to abandon processing in some deeply nested structure, such as breaking out of two or more loops at once.  The `break` statement cannot be used directly since it only exits from the innermost loop.
		-- K & R, 2nd Edition, ch 3, p 65
%
    for ( ... )
        for ( ... ) {
            ...
            if (disaster)
                goto error;
        }
    ...

error:
    clean up the mess
		-- K & R, 2nd Edition, ch 3, p 66
%
A label has the same form as a variable name, and is followed by a colon.  It can be attached to any statement in the same function as the `goto`.  The scope of a label is the entire function.
		-- K & R, 2nd Edition, ch 3, p 66
%
Code involving a `goto` can always be written without one though perhaps at the price of some repeated tests or an extra variable.  With a few exceptions, code that relies on `goto` statements is generally harder to understand and to maintain than code without `goto`s.  Although we are not dogmatic about the matter, it does seem that `goto` statements should be used rarely, if at all.
		-- K & R, 2nd Edition, ch 3, p 66
%
Function declaration and definition is the area where the ANSI standard has made the most visible changes to C...The syntax of function definition also changes, so that declarations and defintions match.  This makes it possible for a compiler to detect many more errors than it could before.  Furthermore, when arguments are properly declared, appropriate type coercions, are performed automatically.
		-- K & R, 2nd Edition, ch 4, p 67
%
Each function definition has the form

    return-type function-name(argument declarations)
    {
        declarations and statements
    }

Various parts may be absent; a minimal function is

    dummy() {}

which does nothing and returns nothing.  A do-nothing function like this is sometimes useful as a place holder during program development.  If the return type is omitted, `int` is assumed.
		-- K & R, 2nd Edition, ch 4, p 69-70
%
The `return` statement is the mechanism for returning a value from the called function to its caller.  Any expression can follow `return`:

    return expression;

The expression will be converted to the return type of the function if necessary.  Parentheses are often used around the expression, but they are optional.
		-- K & R, 2nd Edition, ch 4, p 70
%
The calling function is free to ignore the returned value.  Furthermore, there need be no expression after `return`; in that case, no value is returned to the caller.  Control also returns to the caller with no value when execution "falls off the end" of the function by reaching the closing right brace.  It is not illegal, but probably a sign of trouble, if a function returns a value from one place and no value from another.  In any case, if a function fails to return a value, its "value" is certain to be garbage.
		-- K & R, 2nd Edition, ch 4, p 70
%
If there is an error, say in main.c, that file can be recompiled by itself and the result loaded with the previous object files, with the command

    cc main.c getline.o strindex.o

The `cc` command uses the ".c" versus ".o" naming convention to distinguish source files from object files.
		-- K & R, 2nd Edition, ch 4, p 70-71
%
The declaration

    double sum, atof(char []);

says that `sum` is a `double` variable, and that `atof` is a function that takes one `char[]` argument and returns a `double`.
		-- K & R, 2nd Edition, ch 4, p 72
%
In the light of what we have said about how declarations must match definitions, this might seem surprising.  The reason a mismatch can happen is that if there is no function prototype, a function is implicitly declared by its first appearance in an expression, such as

    sum += atof(line)

If a name that has not been previously declared occurs in an expression and is followed by a left parenthesis, it is declared by context to be a function name, the function is assumed to return an `int`, and nothing is assumed about its arguments.  Furthermore, if a function declaration does not incluce arguments, as in

    double atof();

that too is taken to mean that nothing is to be assumed about the arguments of `atof`; all parameter checking is turned off.  This special meaning of the empty argument list is intended to permit older C programs to compile with new compilers.  But it's a bad idea to use it with new programs.  If the function takes arguments, declare them; if it takes no arguments, use `void`.
		-- K & R, 2nd Edition, ch 4, p 72-73
%
Given `atof` properly declared, we could write `atoi` (convert a string to `int`) in terms of it:

    /* atoi:  convert string s to integer using atof */
    int atoi(char [])
    {
        double atof(char s[]);

        return (int) atof(s);
    }

This operation does potentially discard information, however, so some compilers warn of it.  The cast states explicitly that the operation is intended, and suppresses any warning.
		-- K & R, 2nd Edition, ch 4, p 73
%
A C program consists of a set of external objects, which are either variables or functions.  The adjective "external" is used in contrast to "internal," which describes the arguments and variables defined inside functions.  External variables are defined outside of any function, and are thus potentially available to many functions.  Functions themselves are always external, because C does not allow functions to be defined inside other functions.
		-- K & R, 2nd Edition, ch 4, p 73
%
By default, external variables and functions have the property that all references to them by the same name, even from functions compiled separately, are references to the same thing.  (The standard calls this property external linkage)
		-- K & R, 2nd Edition, ch 4, p 73
%
Because external variables are globally accessible, they provide an alternative to function arguments and return values for communicating data between functions.  Any function may access an external variable by referring to it by name, if the name has been declared somehow.
		-- K & R, 2nd Edition, ch 4, p 74
%
External variables are also useful because of their greater scope and lifetime.  Automatic variables are internal to a function; they come into existence when the function is entered, and disappear when it is left.  External variables, on the other hand, are permanent, so they retain values from one function invocation to the next.
		-- K & R, 2nd Edition, ch 4, p 74
%
Because + and * are commutative operators, the order in which the popped operands are combined is irrelevant, but for - and / the left and right operands must be distinguished.  In

	push(pop() - pop());	/* WRONG */

the order in which the two calls of `pop` are evaluated is not defined.  To guarantee the right order it is necessary to pop the first value into a temporary variable as we did in `main`.
		-- K & R, 2nd Edition, ch 4, p 77
%
The scope of a name is the part of the program within which the name can be used.  For an automatic variable declared at the beginning of a function, the scope is the function in which the name is declared.
		-- K & R, 2nd Edition, ch 4, p 80
%
The scope of an external variable or a function lasts from the point at which it is declared to the end of the file being compiled.
		-- K & R, 2nd Edition, ch 4, p 80
%
[I]f an external variable is to be referred to before it is defined, or if it is defined in a different source file from the one where it is being used, then an `extern` declaration is mandatory.
		-- K & R, 2nd Edition, ch 4, p 80
%
It is important to distinguish between the declaration of an external variable and its definition.  A declaration announces the properties of a variable (primarily its type); a definition also causes storage to be set aside.
		-- K & R, 2nd Edition, ch 4, p 80
%
There must be only one definition of an external variable among all the files that make up the source program; other files may contain `extern` declarations to access it.  (There may also be `extern` declarations in the file containing the definition.)  Array sizes must be specified with the definition, but are optional with an `extern` declaration.
		-- K & R, 2nd Edition, ch 4, p 81
%
There is a tradeoff between the desire that each file have access only to the information it needs for its job and the practical reality that it is harder to maintain more header files.  Up to some moderate program size, it is probably best to have one header file that contains everything that is to be shared between any two parts of the program; that is the decision we made here.  For a much larger program, more organization and more headers would be needed.
		-- K & R, 2nd Edition, ch 4, p 82
%
The `static` declaration, applied to an external variable or function, limits the scope of that object to the rest of the source file being compiled.
		-- K & R, 2nd Edition, ch 4, p 83
%
The external `static` declaration is most often used for variables, but it can be applied to functions as well.  Normally, function names are global, visible to any part of the entire program.  If a function is declared `static`, however, its name is invisible outside of the file in which it is declared.
		-- K & R, 2nd Edition, ch 4, p 83
%
The `static` declaration can also be applied to internal variables.  Internal `static` variables are local to a particular function just as automatic variables are, but unlike automatics, they remain in existence rather than coming and going each time the function is activated.  This means that internal `static` variables provide private, permanent storage within a single function.
		-- K & R, 2nd Edition, ch 4, p 83
%
A `register` declaration advises the compiler that the variable in question will be heavily used.  The idea is that `register` variables are to be placed in machine registers, which may result in smaller and faster programs.  But compilers are free to ignore the advice.
		-- K & R, 2nd Edition, ch 4, p 83
%
The `register` declaration looks like

    register int x;
    register char c;

and so on.  The `register` declaration can only be applied to automatic variables and to the formal parameters of a function.  In this latter case, it looks like

    f(register unsigned m, register long n)
    {
        register int i;
        ...
    }
		-- K & R, 2nd Edition, ch 4, p 83-84
%
In practice, there are restrictions on register variables, reflecting the realities of underlying hardware.  Only a few variables in each function may be kept in registers, and only certain types are allowed.  Excess register declarations are harmless, however, since the word `register` is ignored for excess or disallowed declarations.  And it is not possible to take the address of a register variable, regardless of whether the variable is actually placed in a register.  The specific restrictions on number and types of register variables vary from machine to machine.
		-- K & R, 2nd Edition, ch 4, p 84
%
An automatic variable declared and initialized in a block is initialized each time the block is entered.  A `static` variable is initialized only the first time the block is entered.
		-- K & R, 2nd Edition, ch 4, p 84
%
As a matter of style, it's best to avoid variable names that conceal names in an outer scope; the potential for confusion and error is too great.
		-- K & R, 2nd Edition, ch 4, p 85
%
In the absence of explicit initialization, external and static variables are guaranteed to be initialized to zero; automatic and register variables have undefined (i.e., garbage) initial values.
		-- K & R, 2nd Edition, ch 4, p 85
%
For automatic and register variables, the initializer is not restricted to being a constant:  it may be any expression involving previously defined values, even function calls.
		-- K & R, 2nd Edition, ch 4, p 85
%
In effect, initializations of automatic variables are just shorthand for assignment statements.  Which form to prefer is largely a matter of taste.  We have generally used explicit assignments, because initializers in declarations are harder to see and further away from the point of use.
		-- K & R, 2nd Edition, ch 4, p 86
%
If there are fewer initializers for an array than the number specified, the missing elements will be zero for external, static, and automatic variables.  It is an error to have too many initializers.  There is no way to specify repetition of an initializer, nor to initialize an element in the middle of an array without supplying all the preceding values as well.
		-- K & R, 2nd Edition, ch 4, p 86
%
Character arrays are a special case of initialization; a string may be used instead of the braces and commas notation:

    char pattern[] = "ould";

is a shorthand for the longer but equivalent

    char pattern[] = { 'o', 'u', 'l', 'd', '\0' };

In this case, the array size is five (four characters plus the terminating '\0').
		-- K & R, 2nd Edition, ch 4, p 86
%
When a function calls itself recursively, each invocation gets a fresh set of all the automatic variables, independent of the previous set.
		-- K & R, 2nd Edition, ch 4, p 87
%
Recursion may provide no saving in storage, since somewhere a stack of the values being processed must be maintained.  Nor will it be faster.  But recursive code is more compact, and often much easier to write and understand than the non-recursive equivalent.  Recursion is especially convenient for recursively defined data structures like trees[.]
		-- K & R, 2nd Edition, ch 4, p 88
%
C provides certain language facilities by means of a preprocessor, which is conceptually a separate first step in compilation.  The two most frequently used features are `#include`, to include the contents of a file during compilation, and `#define`, to replace a token by an arbitrary sequence of characters.
		-- K & R, 2nd Edition, ch 4, p 88
%
If the filename is quoted, searching for the file typically begins where the source program was found; if it is not found there, or if the name is enclosed in < and >, searching follows an implementation-defined rule to find the file.
		-- K & R, 2nd Edition, ch 4, p 88
%
`#include` is the preferred way to tie the declarations together for a large program.  It guarantees that all the source files will be supplied with the same definitions and variable declarations, and thus eliminates a particularly nasty kind of bug.  Naturally, when an included file is changed, all files that depend on it must be recompiled.
		-- K & R, 2nd Edition, ch 4, p 89
%
The scope of a name defined with `#define` is from its point of definition to the end of the source file being compiled.
		-- K & R, 2nd Edition, ch 4, p 89
%
Any name may be defined with any replacement text.  For example,

    #define forever for (;;)    /* infinite loop */

defines a new word, `forever`, for an infinite loop.
		-- K & R, 2nd Edition, ch 4, p 89
%
It is also possible to define macros with arguments, so the replacement text can be different for different calls of the macro.  As an example, define a macro called `max`:

    #define max(A, B)   ((A) > (B) ? (A) : (B))

Although it looks like a function call, a use of `max` expands into in-line code.  Each occurrence of an formal character (here `A` or `B`) will be replaced by the corresponding actual argument.  Thus the line

    x = max(p+q, r+s);

will be replaced by the line

    x = ((p+q) > (r+s) ? (p+q) : (r+s));

So long as the arguments are treated consistently, this macro will serve for any data type; there is no need for different kinds of `max` for different data types, as there would be with functions.
		-- K & R, 2nd Edition, ch 4, p 89-90
%
Names may be undefined with `#undef`, usually to ensure that a routine is really a function, not a macro[.]
		-- K & R, 2nd Edition, ch 4, p 90
%
The preprocessor operator ## provides a way to concatenate actual arguments during macro expansion.  If a parameter in the replacement text is adjacent to a ##, the parameter is replaced by the actual argument, the ## and surrounding whitespace are removed, and the result is re-scanned.
		-- K & R, 2nd Edition, ch 4, p 90
%
It is possible to control preprocessing itself with conditional statements that are evaluated during preprocessing.  This provides a way to include code selectively, depending on the value of conditions evaluated during compilation.
		-- K & R, 2nd Edition, ch 4, p 91
%
A pointer is a variable that contains the address of a variable.
		-- K & R, 2nd Edition, ch 5, p 93
%
[T]he type `void *` (pointer to `void`) replaces `char *` as the proper type for a generic pointer.
		-- K & R, 2nd Edition, ch 5, p 93
%
The unary operator `&` gives the address of an object, so the statement

    p = &c;

assigns the address of `c` to the variable `p`, and `p` is said to "point to" `c`.  The & operator only applies to objects in memory: variables and array elements.  It cannot be applied to expressions, constants, or `register` variables.
		-- K & R, 2nd Edition, ch 5, p 93-94
%
The unary operator `*` is the indirection or dereferencing operator; when applied to a pointer, it accesses the object the pointer points to.
		-- K & R, 2nd Edition, ch 5, p 94
%
You should also note the implication that a pointer is constrained to point to a particular kind of object: every pointer points to a specific data type.  (There is one exception: a "pointer to void" is used to hold any type of pointer but cannot be dereferenced itself.)
		-- K & R, 2nd Edition, ch 5, p 94
%
The unary operators * and & bind more tightly than arithmetic operators, so the assignment

    y = *ip + 1

takes whatever `ip` points at, adds 1, and assigns the result to `y`, while

    *ip += 1

increments what `ip` points to, as do

    ++*ip

and

    (*ip)++

The parentheses are necessary in this last example; without them, the expression would increment`ip` instead of what it points to, because unary operators like * and ++ associate right to left.
		-- K & R, 2nd Edition, ch 5, p 94-95
%
Since C passes arguments to functions by value, there is no direct way for the called function to alter a variable in the calling function...[t]he way to obtain the desired effect is for the calling program to pass pointers to the values to be changed:

    swap(&a, &b)

Since the operator & produces the address of a variable, `&a` is a pointer to `a`.  In `swap` itself, the parameters are declared to be pointers, and the operands are accessed indirectly through them.
		-- K & R, 2nd Edition, ch 5, p 95
%
In C, there is a strong relationship between pointers and arrays, strong enough that pointers and arrays should be discussed simultaneously.  Any operation that can be achieved by array subscripting can also be done with pointers.  The pointer version will in general be faster but, at least to the uninitiated, somewhat harder to understand.
		-- K & R, 2nd Edition, ch 5, p 97
%
The correspondence between indexing and pointer arithmetic is very close.  By definition, the value of a variable or expression of type array is the address of element zero of the array.  Thus after the assignment

    pa = &a[0];

`pa` and `a` have identical values.  Since the name of an array is a synonym for the location of the initial element, the assignment `pa=&a[0]` can also be written as

    pa = a;
		-- K & R, 2nd Edition, ch 5, p 99
%
Rather more surprising, at least at first sight, is the fact that a reference to `a[i]` can also be written as `*(a+i)`.  In evaluating `a[i]`, C converts it to `*(a+i)` immediately; the two forms are equivalent.  Applying the operator & to both parts of this equivalence, it follows that `&a[i]` and `a+i` are also identical: `a+i` is the address of the i-th element beyond `a`.  As the other side of this coin, if `pa` is a pointer, expressions may use it with a subscript; `pa[i]` is identical to `*(pa+i)`.  In short, and array-and-index expression is equivalent to one written as a pointer and offset.
		-- K & R, 2nd Edition, ch 5, p 99
%
There is one difference between an array name and a pointer that must be kept in mind.  A pointer is a variable, so `pa=a` and `pa++` are legal.  But an array name is not a variable; constructions like `a=pa` and `a++` are illegal.
		-- K & R, 2nd Edition, ch 5, p 99
%
As formal parameters in a function definition,

    char s[];

and

    char *s;

are equivalent; we prefer the latter because it says more explicitly that the parameter is a pointer.  When an array name is passed to a function, the function can at its convenience believe that it has been handed either an array or a pointer, and manipulate it accordingly.  It can even use both notations if it seems appropriate and clear.
		-- K & R, 2nd Edition, ch 5, p 99-100
%
If one is sure that the elements exist, it is also possible to index backwards in an array; `p[-1]`, `p[-2]`, and so on are syntactically legal, and refer to the elements that immediately precede `p[0]`.  Of course, it is illegal to refer to objects that are not within the array bounds.
		-- K & R, 2nd Edition, ch 5, p 100
%
If `p` is a pointer to some element of an array, then `p++` increments `p` to point to the next element, and `p+=i` increments it to point to `i` elements beyond where it currently does.  These and similar constructions are the simplest forms of pointer or address arithmetic.
		-- K & R, 2nd Edition, ch 5, p 100
%
C is consistent and regular in its approach to address arithmetic; its integration of pointers, arrays, and address arithmetic is one of the strengths of the language.
		-- K & R, 2nd Edition, ch 5, p 100
%
In general a pointer can be initialized just as any other variable can, though normally the only meaningful values are zero or an expression involving the addresses of previously defined data of appropriate type.  The declaration

    static char *allocp = allocbuf;

defines `allocp` to be a character pointer and initializes it to point to the beginning of `allocbuf`, which is the next free position when the program starts.  This could have been written

    static char *allocp = &allocbuf[0];

since the array name is the address of the zeroth element.
		-- K & R, 2nd Edition, ch 5, p 102
%
C guarantees that zero is never a valid address for data, so a return value of zero can be used to signal an abnormal event[.]
		-- K & R, 2nd Edition, ch 5, p 102
%
Pointers and integers are not interchangeable.  Zero is the sole exception; the constant zero may be assigned to a pointer, and a pointer may be compared with the constant zero.  The symbolic constant NULL is often used in place of zero, as a mnemonic to indicate more clearly that this is a special value for a pointer.
		-- K & R, 2nd Edition, ch 5, p 102
%
[P]ointers may be compared under certain conditions.  If p and q point to members of the same array, then relations like ==, !=, <, >=, etc., work properly.  For example,

    p < q

is true if p points to an earlier member of the array than q does.  Any pointer can be meaningfully compared for equality or inequality with zero.  But the behavior is undefined for arithmetic or comparisons with pointers that do not point to members of the same array.  (There is one exception: the address of the first element past the end of an array can be used in pointer arithmetic.)
		-- K & R, 2nd Edition, ch 5, p 102-103
%
[W]e have already observed that a pointer and an integer may be added or subtracted.  The construction

    p + n

means the address of the n-th object p points to; n is scaled according to the size of the objects p points to, which is determined by the declaration of p.  If an `int` is four bytes, for example, the `int` will be scaled by four.
		-- K & R, 2nd Edition, ch 5, p 103
%
The valid pointer operations are assignment of pointers of the same type, adding or subtracting a pointer and an integer, subtracting or comparing two pointers to members of the same array, and assigning or comparing to zero.  All other pointer arithmetic is illegal.  It is not legal to add two pointers, or to mulitply or divide or shift or mask them, or to add `float` or `double` to them, or even, except for `void *`, to assign a pointer of one type to a pointer of another type without a cast.
		-- K & R, 2nd Edition, ch 5, p 103
%
A string constant, written as

    "I am a string"

is an array of characters.  In the internal representation, the array is terminated with the null character '\0' so that programs can find the end.  The length in storage is thus one more than the number of characters between the double quotes.
		-- K & R, 2nd Edition, ch 5, p 104
%
There is an important difference between these definitions:

    char amessage[] = "now is the time";    /* an array */
    char *pmessage = "now is the time";     /* a pointer */

`amessage` is an array, just big enough to hold the sequence of characters and '\0' that initializes it.  Individual characters within the array may be changed but `amessage` will always refer to the same storage.  On the other hand, `pmessage` is a pointer, initialized to point to a string constant; the pointer may subsequently be modified to point elsewhere, but the result is undefined if you try to modify the string constents.
		-- K & R, 2nd Edition, ch 5, p 104
%
Since ++ and -- are either prefix or postfix operators, other combinations of * and ++ and -- occur although less frequently.  For example,

    *--p

decrements p before fetching the character that p points to.  In fact, the pair of expressions

    *p++ = val;     /* push val onto stack */
    val = *--p;     /* pop top of stack into val */

are the standard idioms for pushing and popping a stack[.]
		-- K & R, 2nd Edition, ch 5, p 104
%
Since pointers are variables themselves, they can be stored in arrays just as other variables can.
		-- K & R, 2nd Edition, ch 5, p 107
%
In C, a two-dimensional array is really a one-dimensional array, each of whose elements is an array...Elements are stored by rows, so the rightmost subscript, or column, varies fastest as elements are accessed in storage order.
		-- K & R, 2nd Edition, ch 5, p 112
%
An array is initialized by a list of initializers in braces; each row of a two-dimensional array is initialized by a corresponding sub-list.
		-- K & R, 2nd Edition, ch 5, p 112
%
If a two-dimensional array is to be passed to a function, the parameter declaration in the function must include the number of columns; the number of rows is irrelevant, since what is passed is, as before, a pointer to an array of rows...[o]nly the first dimension (subscript) of an array is free; all the others have to be specified.
		-- K & R, 2nd Edition, ch 5, p 112
%
Newcomers to C are sometimes confused about the difference between a two-dimensional array and an array of pointers[.]  Given the definitions

    int a[10][20];
    int *b[10];

then a[3][4] and b[3][4] are both syntactically legal references to a single `int`.  But a is a true two-dimensional array: 200 `int`-sized locations have been set aside, and the conventional rectangular subscript calculation 20xrow+col is used to find the element a[row][col].  For b, however, the definition only allocates 10 pointers and does not initialize them; initialization must be done explicitly, either statically or with code.
		-- K & R, 2nd Edition, ch 5, p 113
%
The important advantage of the pointer array is that the rows of the array may be of different lengths.
		-- K & R, 2nd Edition, ch 5, p 113
%
[B]y far the most frequent use of arrays of pointers is to store character strings of diverse lengths[.]
		-- K & R, 2nd Edition, ch 5, p 114
%
In environments that support C, there is a way to pass command-line arguments or parameters to a program when it begins executing.  When main is called, it is called with two arguments.  The first (conventionally called `argc`, for argument count) is the number of command-line arguments the program was invoked with; the second (`argv`, for argument vector) is a pointer to an array of character strings that contain the arguments, one per string.
		-- K & R, 2nd Edition, ch 5, p 114
%
By convention, argv[0] is the name by which the program was invoked, so argc is at least 1.  If argc is 1, there are no command-line arguments after the program name.
		-- K & R, 2nd Edition, ch 5, p 115
%
The first optional argument is argv[1] and the last is argv[argc-1]; additionally, the standard requires that argv[argc] be a null pointer.
		-- K & R, 2nd Edition, ch 5, p 115
%
Notice that *++argv is a pointer to an argument string, so (*++argv)[0] is its first character.  (An alternate valid form would be **++argv.)  Because [] binds tighter than * and ++, the parentheses are necessary; without them the expression would be taken as *++(argv[0]).  In fact, that is what we used in the inner loop, where the task is to walk along a specific argument string.  In the inner loop, the expression *++argv[0] increments the pointer argv[0]!
		-- K & R, 2nd Edition, ch 5, p 118
%
In C, a function itself is not a variable, but it is possible to define pointers to functions, which can be assigned, placed in arrays, passed to functions, returned by functions, and so on.
		-- K & R, 2nd Edition, ch 5, p 118
%
A sort often consists of three parts -- a comparison that determines the ordering of any pair of objects, an exchange that reverses their order, and a sorting algorithm that makes comparisons and exchanges until the objects are in order.  The sorting algorithm is independent of the comparison and exchange operations, so by passing different comparison and exchange functions to it, we can arrange to sort by different criteria.
		-- K & R, 2nd Edition, ch 5, p 118-119
%
In the call to `qsort`, `strcmp` and `numcmp` are addresses of functions.  Since they are known to be functions, the & operator is not necessary, in the same way that it is not needed before an array name.
		-- K & R, 2nd Edition, ch 5, p 119
%
Any pointer can be cast to `void *` and back again without loss of information[.]
		-- K & R, 2nd Edition, ch 5, p 120
%
The fourth parameter of qsort is

    int (*comp)(void *, void *)

which says that `comp` is a pointer to a function that has two `void *` arguments and returns an `int`...The parentheses are needed so the components are correctly associated; without them,

    int *comp(void *, void *)       /* WRONG */

says that `comp` is a function returning a poiter to an `int`, which is very different.
		-- K & R, 2nd Edition, ch 5, p 120
%
One good way to synthesize [complicated] declarations is in small steps with `typedef`[.]
		-- K & R, 2nd Edition, ch 5, p 122
%
`dcl` is based on the grammar that specifies a declarator, which is spelled out precisely in Appendix A, Section 8.5; this is a simplified form:

    dcl:            optional *'s direct-dcl
    direct-dcl      name
                    (dcl)
                    direct-dcl()
                    direct-dcl[optional size]

In words, a dcl is a direct-dcl, perhaps preceded by *'s.  A direct-dcl is a name, or a parenthesized dcl, or a direct-dcl followed by parentheses, or a direct-dcl followed by brackets with an optional size.
		-- K & R, 2nd Edition, ch 5, p 122-123
%
A structure is a collection of one or more variables, possibly of different types, grouped together under a single name for convenient handling.  (Structures are called "records" in some languages, notably Pascal.)  Structures help to organize complicated data, particularly in large programs, because they permit a group of related variables to be treated as a unit instead of as separate entities.
		-- K & R, 2nd Edition, ch 6, p 127
%
The main change made by the ANSI standard is to define structure assignment -- structures may be copied and assigned to, passed to functions, and returned by functions.  This has been supported by most compilers for many years, but the properties are now precisely defined.  Automatic structures and arrays may now also be initialized.
		-- K & R, 2nd Edition, ch 6, p 127
%
The keyword `struct` introduces a structure declaration, which is a list of declarations enclosed in braces.  An optional name called a structure tag may follow the word `struct`.  The tag names this kind of structure, and can be used subsequently as a shorthand for the part of the declaration in braces.
		-- K & R, 2nd Edition, ch 6, p 128
%
The variables named in a structure are called members.  A structure member or tag and an ordinary (i.e., non-member) variable can have the same name without conflict, since they can always be distinguished by context.  Furthermore, the same member names may occur in different structures, although as a matter of style one would normally use the same names only for closely related objects.
		-- K & R, 2nd Edition, ch 6, p 128
%
A `struct` declaration defines a type.  The right brace that terminates the list of members may be followed by a list of variables, just as for any basic type.  That is,

    struct { ... } x, y, z;

is syntactically analogous to

    int x, y, z;

in the sense that each statement declares x, y and z to be variables of the named type and causes space to be set aside for them.
		-- K & R, 2nd Edition, ch 6, p 128
%
A structure declaration that is not followed by a list of variables reserves no storage; it merely describes a template or the shape of a structure.  If the declaration is tagged, however, the tag can be used later in definitions of instances of the structure.
		-- K & R, 2nd Edition, ch 6, p 128
%
A structure can be initialized by following its definition with a list of initializers, each a constant expression, for the members:

    struct point maxpt = { 320, 200 };

An automatic structure may also be initialized or by assignment or by calling a function that returns a structure of the right type.
		-- K & R, 2nd Edition, ch 6, p 128
%
The only legal operations on a structure are copying it or assigning to it as a unit, taking its address as &, and accessing its members.  Copy and assignment include passing arguments to functions and returning values from functions as well.  Structures may not be compared.  A structure may be initialized by a list of constant member values; an automatic structure may also be initialized by an assignment.
		-- K & R, 2nd Edition, ch 6, p 129
%
[S]tructure parameters are passed by value like any others.
		-- K & R, 2nd Edition, ch 6, p 130
%
If a large structure is to be passed to a function, it is generally more efficient to pass a pointer than to copy the whole structure.  Structure pointers are just like pointers to ordinary variables.  The declaration

    struct point *pp;

    says that `pp` is a pointer to a structure of type `struct point`.  If `pp` points to a `point` structure, `*pp` is the structure, and `(*pp).x` and `(*pp).y` are the members.  To use `pp`, we might write, for example,

    struct point origin, *pp;
    pp = &origin;
    printf("origin is (%d,%d)\n", (*pp).x, (*pp).y);

The parentheses are necessary in `(*pp).x` because the precedence of the structure operator . is higher than *.  The expression `*pp.x` means `*(pp.x)`, which is illegal here because `x` is not a pointer.
		-- K & R, 2nd Edition, ch 6, p 131
%
Pointers to structures are so frequently used that an alternative notation is provided as a shorthand.  If `p` is a pointer to a structure, then

    p->member-of-structure

refers to the particular member.
		-- K & R, 2nd Edition, ch 6, p 131
%
Both . and -> associate from left to right, so if we have

    struct rect r, *rp = &r;

then these four expressions are equivalent:

    r.pt1.x
    rp->pt1.x
    (r.pt1).x
    (rp->pt1).x
		-- K & R, 2nd Edition, ch 6, p 131
%
The structure operators . and ->, together with () for function calls and [] for subscripts, are at the top of the precedence hierarchy and thus bind very tightly.
		-- K & R, 2nd Edition, ch 6, p 132
%
[G]iven the declaration

    struct {
        int len;
        char *str;
    } *p;

then

    ++p->len

increments `len`, not `p`, because the implied parenthesization is `++(p->len)`.  Parentheses can be used to alter the binding:  `(++p)->len` increments `p` before accessing `len`, and `(p++)->len` increments `p` afterward.  (This last set of parentheses is unnecessary.)
In the same way, `*p->str` fetches whatever `str` points to; `*p->str++` increments `str` after accessing whatever it points to (just like `*s++`); `(*p->str)++` increments whatever `str` points to; and `*p++->str` increments `p` after accessing whatver `str` points to.
		-- K & R, 2nd Edition, ch 6, p 132
%
Since the structure `keytab` contains a constant set of names, it is easiest to make it an external variable and initialize it once and for all when it is defined.  The structure initialization is analagous to earlier ones -- the definition is followed by a list of initializers enclosed in braces:

    struct key {
        char *word;
        int count;
    } keytab[]= {
        "auto", 0,
        "break", 0,
        "case", 0,
        /* ... */
        "void", 0,
        "volatile", 0,
        "while", 0
    };

The initializers are listed in pairs corresponding to the structure members.  It would be more precise to enclose initializers for each "row" or structure in braces, as in

    { "auto", 0 },
    { "break", 0 },
    { "case", 0 },
    ...

but the inner braces are not necessary when the initializers are simple variables or character strings, and when all are present.  As usual, the number of entries in the array `keytab` will be computed if initializers are present and the [] is left empty.
		-- K & R, 2nd Edition, ch 6, p 133
%
