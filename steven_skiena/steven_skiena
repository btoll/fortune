There is a fundamental difference between algorithms, which always produce a correct result, and heuristics, which may usually do a good job but withouth providing any guarantee.
		-- Steven S. Skiena, The Algorithm Design Manual, 2nd Edition, ch 1, p 9
%
Reasonable-looking algorithms can easily be incorrect.  Algorithm correctness is a property that must be carefully demonstrated.
		-- Steven S. Skiena, The Algorithm Design Manual, 2nd Edition, ch 1, p 11
%
The heart of any algorithm is an idea.  If your idea is not clearly revealed when you express an algorithm, then you are using too low-level a notation to describe it.
		-- Steven S. Skiena, The Algorithm Design Manual, 2nd Edition, ch 1, p 12
%
An important and honorable technique in algorithm design is to narrow the set of allowable instances until there is a correct and efficient algorithm.  For example, we can restrict a graph problem from general graphs down to trees, or a geometric problem from two dimensions down to one.
		-- Steven S. Skiena, The Algorithm Design Manual, 2nd Edition, ch 1, p 13
%
Searching for counterexamples is the best way to disprove the correctness of a heuristic.
		-- Steven S. Skiena, The Algorithm Design Manual, 2nd Edition, ch 1, p 14
%
Mathematical induction is usually the right way to verify the correctness of a recursive or incremental insertion algorithm.
		-- Steven S. Skiena, The Algorithm Design Manual, 2nd Edition, ch 1, p 16
%
Modeling your application in terms of well-defined structures and algorithms is the most important single step towards a solution.
		-- Steven S. Skiena, The Algorithm Design Manual, 2nd Edition, ch 1, p 21
%
Algorithms can be understood and studied in a language- and machine-independent manner.
		-- Steven S. Skiena, The Algorithm Design Manual, 2nd Edition, ch 2, p 33
%
The Big Oh notation and worst-case analysis are tools that greatly simplify our ability to compare the efficiency of algorithms.
		-- Steven S. Skiena, The Algorithm Design Manual, 2nd Edition, ch 2, p 35
%
Although esoteric functions arise in advanced algorithm analysis, a small variety of time complexities suffice and account for most algorithms that are widely used in practice.
		-- Steven S. Skiena, The Algorithm Design Manual, 2nd Edition, ch 2, p 40
%
Logarithms arise whenever things are repeatedly halved or doubled.
		-- Steven S. Skiena, The Algorithm Design Manual, 2nd Edition, ch 2, p 50
%
Dynamic memory allocation provides us with flexibility on how and where we use our limited storage resources.
		-- Steven S. Skiena, The Algorithm Design Manual, 2nd Edition, ch 3, p 71
%
Data structure design must balance all the different operations it supports.  The fastest data structure to support both operations A and B may well not be the fastest structure to support either operation A or B.
		-- Steven S. Skiena, The Algorithm Design Manual, 2nd Edition, ch 3, p 75
%
Picking the wrong data structure for the job can be disastrous in terms of performance.  Identifying the very best data structure is usually not as critical, because there can be several choices that perform similarly.
		-- Steven S. Skiena, The Algorithm Design Manual, 2nd Edition, ch 3, p 82
%
Building algorithms around data structures such as dictionaries and priority queues leads to both clean structure and good performance.
		-- Steven S. Skiena, The Algorithm Design Manual, 2nd Edition, ch 3, p 84
%
